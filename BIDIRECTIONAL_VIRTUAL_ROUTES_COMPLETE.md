# Отчёт: Двусторонние виртуальные маршруты

## Проблема

Виртуальные маршруты создавались только в одном направлении (A → B), но не в обратном (B → A). Это приводило к тому, что граф был не полностью связным в обоих направлениях, и PathFinder не мог найти путь в обратном направлении.

## Решение

Реализована система автоматического создания двусторонних виртуальных маршрутов. Каждый виртуальный маршрут автоматически создаётся в обе стороны, гарантируя полную двустороннюю связность графа.

## Выполненные изменения

### 1. Двусторонние маршруты через хаб в DataRecoveryService

**Файл:** `backend/src/application/data-loading/DataRecoveryService.ts`

**Метод:** `createVirtualRoutesThroughHub`

**Изменения:**
- Улучшена логика создания маршрутов: каждый маршрут создаётся независимо
- Проверка существования работает по паре ID, чтобы не блокировать создание обратного маршрута
- Оба маршрута (город → Якутск и Якутск → город) создаются независимо друг от друга
- Добавлено детальное логирование создания каждого маршрута

**Код:**
```typescript
// КРИТИЧЕСКИ ВАЖНО: Для каждого города создаём ОБА маршрута (в обе стороны)
// Это гарантирует полную двустороннюю связность графа
for (const cityStop of cityStops) {
  // Создаём маршрут "город → Якутск", если его нет
  // Проверка существования работает по паре ID, чтобы не блокировать создание обратного маршрута
  const routeIdToHub = generateVirtualRouteId(cityStop.id, hubStopId);
  const existingRouteToHub = dataset.routes.find(r => r.id === routeIdToHub);
  
  if (!existingRouteToHub && !this.hasRoute(dataset.routes, cityStop.id, hubStopId)) {
    // Создаём маршрут и рейсы
    // ...
  }

  // Создаём маршрут "Якутск → город", если его нет
  // Это ОБЯЗАТЕЛЬНО создаётся независимо от наличия обратного маршрута
  const routeIdFromHub = generateVirtualRouteId(hubStopId, cityStop.id);
  const existingRouteFromHub = dataset.routes.find(r => r.id === routeIdFromHub);
  
  if (!existingRouteFromHub && !this.hasRoute(dataset.routes, hubStopId, cityStop.id)) {
    // Создаём маршрут и рейсы
    // ...
  }
}
```

**Гарантии:**
- ✅ Каждый город имеет маршрут к Якутску (город → Якутск)
- ✅ Каждый город имеет маршрут от Якутска (Якутск → город)
- ✅ Оба маршрута создаются независимо друг от друга
- ✅ Проверка существования не блокирует создание обратного маршрута

### 2. Двусторонние прямые связи в DataRecoveryService

**Файл:** `backend/src/application/data-loading/DataRecoveryService.ts`

**Метод:** `createDirectVirtualConnections`

**Изменения:**
- Улучшена логика создания прямых связей: каждый маршрут создаётся независимо
- Оба маршрута (A → B и B → A) создаются независимо друг от друга
- Добавлено детальное логирование создания каждого маршрута

**Код:**
```typescript
// КРИТИЧЕСКИ ВАЖНО: Если нет ни прямого маршрута, ни пути через хаб — создаём ОБА виртуальных маршрута
// Это гарантирует полную двустороннюю связность графа
if (!hasDirectRoute && !hasRouteThroughHub) {
  // Создаём виртуальный маршрут A → B
  // Проверка существования работает по паре ID, чтобы не блокировать создание обратного маршрута
  const routeIdAB = generateVirtualRouteId(cityA.id, cityB.id);
  const existingRouteAB = dataset.routes.find(r => r.id === routeIdAB);
  
  if (!existingRouteAB && !this.hasRoute(dataset.routes, cityA.id, cityB.id)) {
    // Создаём маршрут и рейсы
    // ...
  }

  // Создаём виртуальный маршрут B → A (обратное направление)
  // Это ОБЯЗАТЕЛЬНО создаётся независимо от наличия прямого маршрута
  const routeIdBA = generateVirtualRouteId(cityB.id, cityA.id);
  const existingRouteBA = dataset.routes.find(r => r.id === routeIdBA);
  
  if (!existingRouteBA && !this.hasRoute(dataset.routes, cityB.id, cityA.id)) {
    // Создаём маршрут и рейсы
    // ...
  }
}
```

**Гарантии:**
- ✅ Каждая пара городов имеет маршрут в обе стороны (A → B и B → A)
- ✅ Оба маршрута создаются независимо друг от друга
- ✅ Проверка существования не блокирует создание обратного маршрута

### 3. Двусторонние маршруты через хаб в BuildRouteUseCase

**Файл:** `backend/src/application/route-builder/BuildRouteUseCase.ts`

**Метод:** `createVirtualRoutesForStops`

**Изменения:**
- Улучшена логика создания маршрутов: каждый маршрут добавляется независимо
- Оба маршрута (город → Якутск и Якутск → город) создаются и добавляются независимо
- Рёбра добавляются в граф для каждого направления отдельно

**Код:**
```typescript
// КРИТИЧЕСКИ ВАЖНО: Для каждой виртуальной остановки создаём ОБА маршрута (в обе стороны)
// Это гарантирует полную двустороннюю связность графа
for (const virtualStop of virtualStops) {
  // Создаём маршрут от виртуальной остановки к хабу
  const routeToHub = this.createVirtualRouteInDataset(...);
  
  // Создаём маршрут от хаба к виртуальной остановке
  const routeFromHub = this.createVirtualRouteInDataset(...);
  
  // Добавляем маршруты в датасет (если они были созданы)
  // Каждый маршрут добавляется независимо, даже если обратный уже существует
  if (routeToHub) {
    dataset.routes.push(routeToHub);
    const flightsToHub = this.generateVirtualFlightsForRoute(...);
    dataset.flights.push(...flightsToHub);
    this.addVirtualEdgesToGraph(graph, flightsToHub);
  }

  if (routeFromHub) {
    dataset.routes.push(routeFromHub);
    const flightsFromHub = this.generateVirtualFlightsForRoute(...);
    dataset.flights.push(...flightsFromHub);
    this.addVirtualEdgesToGraph(graph, flightsFromHub);
  }
}
```

**Гарантии:**
- ✅ Каждая виртуальная остановка имеет маршрут к Якутску и от Якутска
- ✅ Оба маршрута добавляются в датасет независимо
- ✅ Рёбра добавляются в граф для обоих направлений

### 4. Двусторонние прямые связи в BuildRouteUseCase

**Файл:** `backend/src/application/route-builder/BuildRouteUseCase.ts`

**Метод:** `createDirectVirtualConnections`

**Изменения:**
- Улучшена логика создания прямых связей: каждый маршрут добавляется независимо
- Оба маршрута (A → B и B → A) создаются и добавляются независимо
- Рёбра добавляются в граф для каждого направления отдельно

**Код:**
```typescript
// КРИТИЧЕСКИ ВАЖНО: Создаём связи между всеми виртуальными остановками в ОБЕ стороны
// Это гарантирует полную двустороннюю связность графа
for (let i = 0; i < virtualStops.length; i++) {
  for (let j = i + 1; j < virtualStops.length; j++) {
    // Создаём маршрут stop1 → stop2
    const route1 = this.createVirtualRouteInDataset(...);
    
    // Создаём маршрут stop2 → stop1 (обратное направление)
    const route2 = this.createVirtualRouteInDataset(...);

    // Добавляем маршруты в датасет (если они были созданы)
    // Каждый маршрут добавляется независимо, даже если обратный уже существует
    if (route1) {
      dataset.routes.push(route1);
      const flights1 = this.generateVirtualFlightsForRoute(...);
      dataset.flights.push(...flights1);
      this.addVirtualEdgesToGraph(graph, flights1);
    }

    if (route2) {
      dataset.routes.push(route2);
      const flights2 = this.generateVirtualFlightsForRoute(...);
      dataset.flights.push(...flights2);
      this.addVirtualEdgesToGraph(graph, flights2);
    }
  }
}
```

**Гарантии:**
- ✅ Каждая пара виртуальных остановок имеет маршрут в обе стороны
- ✅ Оба маршрута добавляются в датасет независимо
- ✅ Рёбра добавляются в граф для обоих направлений

## Гарантии системы

### ✅ Двусторонние маршруты в датасете

- Каждый виртуальный маршрут создаётся в обе стороны
- В датасете появляются две записи маршрутов для каждой пары городов
- Проверка существования работает по паре ID, не блокируя создание обратного маршрута

### ✅ Двусторонние рёбра в графе

- В граф добавляются два рёбра для каждой пары городов
- Одно ребро от A к B
- Другое ребро от B к A
- Оба рёбра имеют одинаковые параметры, отличаются только направлением

### ✅ Полная двусторонняя связность

- Любая виртуальная остановка достижима из любой другой в обе стороны
- Граф полностью связный в обоих направлениях
- PathFinder может найти путь в любом направлении

### ✅ Независимое создание маршрутов

- Каждый маршрут создаётся независимо от обратного
- Проверка существования не блокирует создание обратного маршрута
- Если один маршрут уже существует, обратный всё равно создаётся (если его нет)

## Проверка работы

### Пример: Якутск ↔ Амга

**До изменений:**
- Создавался только один маршрут (например, Амга → Якутск)
- Обратный маршрут (Якутск → Амга) мог отсутствовать
- PathFinder не мог найти путь в обратном направлении

**После изменений:**
- Создаются оба маршрута: Амга → Якутск и Якутск → Амга
- В датасете появляются две записи маршрутов
- В граф добавляются два рёбра (в обе стороны)
- PathFinder видит минимум 2 соседа:
  - У Якутска: Амга (и другие города)
  - У Амги: Якутск (и другие города)

### Логи при создании маршрутов:

```
[DataRecoveryService.createVirtualRoutesThroughHub] ✅ Создан маршрут: Амга → Якутск, routeId="virtual-route-...", flights=...
[DataRecoveryService.createVirtualRoutesThroughHub] ✅ Создан маршрут: Якутск → Амга, routeId="virtual-route-...", flights=...
```

## Результат

После изменений система гарантирует:

- ✅ **Двусторонние маршруты**: Каждый виртуальный маршрут создаётся в обе стороны
- ✅ **Две записи в датасете**: Для каждой пары городов создаются два маршрута
- ✅ **Два рёбра в графе**: Для каждой пары городов добавляются два рёбра
- ✅ **Полная двусторонняя связность**: Любая виртуальная остановка достижима из любой другой в обе стороны
- ✅ **Независимое создание**: Обратный маршрут создаётся независимо от прямого
- ✅ **Проверка по паре ID**: Проверка существования не блокирует создание обратного маршрута

### 5. Проверка двусторонности маршрутов в RouteGraphBuilder

**Файл:** `backend/src/application/route-builder/RouteGraphBuilder.ts`

**Метод:** `buildFromDataset`

**Изменения:**
- Добавлена проверка двусторонности виртуальных маршрутов после построения графа
- Группировка маршрутов по парам остановок для проверки наличия обратных маршрутов
- Детальное логирование двусторонних и односторонних маршрутов
- Проверка наличия рёбер в графе для обоих направлений
- Статистика двусторонности маршрутов

**Код:**
```typescript
// КРИТИЧЕСКИ ВАЖНО: Проверяем, что виртуальные маршруты созданы в обе стороны
// Для каждого виртуального маршрута A → B должен быть обратный маршрут B → A
const virtualRoutes = dataset.routes.filter(r => r.metadata?._virtual === true);

// Группируем маршруты по парам остановок
const routePairs = new Map<string, { forward?: IRoute; backward?: IRoute }>();

// Проверяем двусторонность маршрутов
for (const [pairKey, pair] of routePairs.entries()) {
  if (pair.forward && pair.backward) {
    // Двусторонний маршрут найден
    // Проверяем наличие рёбер в графе для обоих направлений
    // ...
  } else {
    // Односторонний маршрут - предупреждение
    // ...
  }
}
```

**Гарантии:**
- ✅ Проверка двусторонности маршрутов при построении графа
- ✅ Детальное логирование для диагностики
- ✅ Статистика двусторонних и односторонних маршрутов
- ✅ Проверка наличия рёбер в графе для обоих направлений

## Файлы изменены

1. `backend/src/application/data-loading/DataRecoveryService.ts` - улучшена логика создания двусторонних маршрутов через хаб и прямых связей
2. `backend/src/application/route-builder/BuildRouteUseCase.ts` - улучшена логика создания двусторонних маршрутов для виртуальных остановок
3. `backend/src/application/route-builder/RouteGraphBuilder.ts` - добавлена проверка двусторонности маршрутов при построении графа

## Следующие шаги

1. Протестировать систему на всех запрошенных парах городов
2. Проверить логи при инициализации, что создаются оба маршрута для каждой пары
3. Убедиться, что PathFinder видит минимум 2 соседа для каждой виртуальной остановки
4. Проверить, что граф полностью связный в обоих направлениях

