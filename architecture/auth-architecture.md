# Архитектура авторизации и профиля

## 1. Общие принципы

### 1.1 Схема аутентификации
- **JWT (JSON Web Token)** — для аутентификации
- **Bearer Token** — передача токена в заголовке
- **Stateless** — сервер не хранит сессии

### 1.2 Безопасность
- Хеширование паролей (bcrypt)
- HTTPS для передачи токенов
- Валидация токенов на каждом запросе
- Срок действия токена

## 2. Структура JWT токена

### 2.1 Payload токена
```json
{
  "userId": "user-uuid",
  "email": "user@example.com",
  "iat": 1705312800,
  "exp": 1705399200
}
```

**Поля:**
- `userId` — ID пользователя
- `email` — Email пользователя
- `iat` — Время выдачи токена (Unix timestamp)
- `exp` — Время истечения токена (Unix timestamp)

### 2.2 Срок действия токена
- **Access Token:** 24 часа
- **Refresh Token:** 7 дней (для будущей реализации)

## 3. Процесс авторизации

### 3.1 Регистрация

**Шаги:**
1. Пользователь вводит данные (email, пароль, полное имя)
2. Frontend валидирует данные
3. Frontend отправляет POST запрос на `/api/v1/auth/register`
4. Backend проверяет:
   - Email не занят
   - Пароль соответствует требованиям
5. Backend хеширует пароль (bcrypt)
6. Backend создает пользователя в PostgreSQL
7. Backend генерирует JWT токен
8. Backend возвращает пользователя и токен
9. Frontend сохраняет токен в localStorage
10. Frontend перенаправляет в ЛК

**Требования к паролю:**
- Минимум 8 символов
- Буквы и цифры
- Рекомендуется: специальные символы

---

### 3.2 Вход

**Шаги:**
1. Пользователь вводит email и пароль
2. Frontend отправляет POST запрос на `/api/v1/auth/login`
3. Backend ищет пользователя по email в PostgreSQL
4. Backend проверяет пароль (bcrypt.compare)
5. Backend обновляет `last_login_at` в PostgreSQL
6. Backend генерирует JWT токен
7. Backend возвращает пользователя и токен
8. Frontend сохраняет токен в localStorage
9. Frontend перенаправляет в ЛК

**Ошибки:**
- `401` — Неверный email или пароль
- `400` — Ошибки валидации

---

### 3.3 Выход

**Шаги:**
1. Пользователь нажимает "Выход"
2. Frontend отправляет POST запрос на `/api/v1/auth/logout` (опционально)
3. Frontend удаляет токен из localStorage
4. Frontend перенаправляет на главную страницу

**Примечание:** В MVP выход происходит только на клиенте (удаление токена). Серверная инвалидация токена не требуется (stateless).

---

### 3.4 Проверка авторизации

**Шаги:**
1. Frontend отправляет запрос с заголовком `Authorization: Bearer {token}`
2. Backend извлекает токен из заголовка
3. Backend проверяет:
   - Токен валиден (подпись, срок действия)
   - Пользователь существует в PostgreSQL
4. Backend извлекает `userId` из токена
5. Backend выполняет запрос от имени пользователя

**Ошибки:**
- `401` — Токен отсутствует или невалиден
- `401` — Токен истек
- `401` — Пользователь не найден

---

## 4. Хранение токена на Frontend

### 4.1 LocalStorage
**Использование:** Хранение JWT токена

**Преимущества:**
- Простота реализации
- Токен сохраняется между сессиями

**Недостатки:**
- Уязвимость к XSS атакам
- Токен доступен JavaScript

**Реализация:**
```javascript
// Сохранение токена
localStorage.setItem('token', token);

// Получение токена
const token = localStorage.getItem('token');

// Удаление токена
localStorage.removeItem('token');
```

### 4.2 HttpOnly Cookie (будущее)
**Использование:** Более безопасное хранение токена

**Преимущества:**
- Защита от XSS атак
- Токен недоступен JavaScript

**Недостатки:**
- Требует настройки CORS
- Более сложная реализация

---

## 5. Middleware авторизации

### 5.1 Backend Middleware
**Назначение:** Проверка JWT токена на каждом запросе

**Логика:**
1. Извлечение токена из заголовка `Authorization`
2. Проверка формата токена
3. Валидация токена (подпись, срок действия)
4. Извлечение `userId` из токена
5. Проверка существования пользователя в PostgreSQL
6. Добавление `userId` в контекст запроса

**Защищенные endpoints:**
- `/api/v1/orders/*` — все операции с заказами
- `/api/v1/users/*` — операции с профилем
- `/api/v1/assistant/chat` — чат с помощником (опционально)

**Публичные endpoints:**
- `/api/v1/auth/*` — авторизация
- `/api/v1/routes/*` — поиск маршрутов
- `/api/v1/attractions/*` — достопримечательности
- `/api/v1/events/*` — события

---

## 6. Профиль пользователя

### 6.1 Структура профиля

**Поля пользователя (PostgreSQL):**
- `id` — UUID пользователя
- `email` — Email
- `password_hash` — Хеш пароля
- `full_name` — Полное имя
- `phone` — Телефон (опционально)
- `avatar_url` — URL аватара в MinIO (опционально)
- `created_at` — Дата регистрации
- `updated_at` — Дата обновления
- `last_login_at` — Дата последнего входа

**Настройки пользователя (PostgreSQL):**
- `notifications_enabled` — Включены ли уведомления
- `language` — Язык интерфейса (ru, en)
- `theme` — Тема (light, dark)

---

### 6.2 Получение профиля

**Endpoint:** `GET /api/v1/users/profile`

**Шаги:**
1. Frontend отправляет запрос с JWT токеном
2. Backend проверяет токен
3. Backend получает `userId` из токена
4. Backend получает пользователя из PostgreSQL
5. Backend получает настройки из `user_preferences`
6. Backend возвращает профиль

**Ответ:**
```json
{
  "id": "user-uuid",
  "email": "user@example.com",
  "fullName": "Иван Иванов",
  "phone": "+7 999 123 45 67",
  "avatarUrl": "http://minio:9000/bucket/images/users/avatar.jpg",
  "createdAt": "2024-01-15T10:00:00Z",
  "preferences": {
    "notifications": true,
    "language": "ru"
  }
}
```

---

### 6.3 Обновление профиля

**Endpoint:** `PUT /api/v1/users/profile`

**Шаги:**
1. Пользователь изменяет данные профиля
2. Frontend валидирует данные
3. Frontend отправляет PUT запрос с JWT токеном
4. Backend проверяет токен
5. Backend получает `userId` из токена
6. Backend обновляет пользователя в PostgreSQL
7. Backend возвращает обновленный профиль

**Ошибки:**
- `400` — Ошибки валидации
- `401` — Не авторизован

---

### 6.4 Загрузка аватара

**Endpoint:** `POST /api/v1/users/profile/avatar`

**Шаги:**
1. Пользователь выбирает файл аватара
2. Frontend валидирует файл (размер, формат)
3. Frontend отправляет POST запрос с FormData и JWT токеном
4. Backend проверяет токен
5. Backend валидирует файл:
   - Формат: JPEG, PNG, WebP
   - Размер: максимум 5 MB
6. Backend загружает файл в MinIO в папку `images/users/`
7. Backend получает URL файла из MinIO
8. Backend обновляет `avatar_url` в PostgreSQL
9. Backend возвращает обновленный профиль

**Ошибки:**
- `400` — Неверный формат или размер файла
- `401` — Не авторизован

---

## 7. Защита endpoints

### 7.1 Принцип наименьших привилегий
- Пользователь может изменять только свой профиль
- Пользователь может просматривать только свои заказы
- Пользователь не может изменять заказы других пользователей

### 7.2 Проверка прав доступа

**Пример: Получение заказа**
1. Backend получает `userId` из JWT токена
2. Backend получает заказ из PostgreSQL
3. Backend проверяет: `order.user_id === userId`
4. Если не совпадает, возвращает `403 Forbidden`

---

## 8. Обработка истечения токена

### 8.1 На Frontend
**Сценарий:** Токен истек

**Действия:**
1. Frontend получает `401 Unauthorized` от Backend
2. Frontend удаляет токен из localStorage
3. Frontend перенаправляет на страницу входа
4. Frontend показывает сообщение: "Сессия истекла. Пожалуйста, войдите снова"

---

### 8.2 На Backend
**Сценарий:** Токен истек

**Действия:**
1. Backend проверяет срок действия токена
2. Если токен истек, возвращает `401 Unauthorized`
3. В ответе указывается причина: "Token expired"

---

## 9. Безопасность паролей

### 9.1 Хеширование
**Алгоритм:** bcrypt

**Параметры:**
- Salt rounds: 10

**Пример:**
```javascript
// Хеширование пароля
const hash = await bcrypt.hash(password, 10);

// Проверка пароля
const isValid = await bcrypt.compare(password, hash);
```

### 9.2 Требования к паролю
- Минимум 8 символов
- Буквы и цифры
- Рекомендуется: специальные символы

**Валидация на Backend:**
- Проверка минимальной длины
- Проверка наличия букв и цифр

---

## 10. Логирование авторизации

### 10.1 События для логирования
- Успешная регистрация
- Успешный вход
- Неудачная попытка входа
- Выход
- Обновление профиля

### 10.2 Данные для логирования
- Timestamp
- User ID (если доступен)
- IP адрес
- User Agent
- Тип события

---

## 11. Будущие улучшения

### 11.1 Refresh Token
- Долгоживущий токен для обновления access token
- Хранение в httpOnly cookie
- Автоматическое обновление токена

### 11.2 Двухфакторная аутентификация (2FA)
- SMS код
- Email код
- TOTP (Time-based One-Time Password)

### 11.3 Восстановление пароля
- Отправка ссылки на email
- Сброс пароля через токен

### 11.4 OAuth
- Вход через Google
- Вход через Facebook
- Вход через другие провайдеры

