# ЧАСТЬ 6: Интеграция с существующим backend — Вариант B

**Дата:** 2024-11-18  
**Версия:** 1.0  
**Статус:** Integration Specification  
**Архитектурный вариант:** B (Medium Complexity)

---

## Содержание

- [6.1 Цель интеграции](#61-цель-интеграции)
- [6.2 Изменения в BuildRouteUseCase](#62-изменения-в-buildrouteusecase)
- [6.3 Изменения в RouteGraphBuilder](#63-изменения-в-routegraphbuilder)
- [6.4 Обратная совместимость](#64-обратная-совместимость-backward-compatibility)
- [6.5 Изменения в Presentation Layer](#65-изменения-в-presentation-layer)
- [6.6 Последовательность интеграции](#66-последовательность-интеграции-пошагово)
- [6.7 Сценарии интеграции](#67-сценарии-интеграции)
- [6.8 Риски интеграции и их митигация](#68-риски-интеграции-и-их-митигация)
- [6.9 Готовность к коду](#69-готовность-к-коду)

---

## 6.1 Цель интеграции

### Зачем нужна интеграция

Существующая система построения маршрутов жёстко привязана к OData API: при недоступности внешнего источника данных приложение не может работать. Интеграция адаптивной системы загрузки транспортных данных (Вариант B) устраняет эту проблему, внедряя три режима работы: REAL (реальные данные), RECOVERY (восстановленные данные) и MOCK (заглушка). Система становится отказоустойчивой и продолжает функционировать даже при полной недоступности OData.

### Что должна изменить интеграция

**Архитектурные изменения:**
- Разделение загрузки данных и построения графа маршрутов (separation of concerns)
- Внедрение слоя абстракции над источниками транспортных данных
- Добавление валидации качества данных и автоматического восстановления
- Расширение API ответов метаданными о режиме и качестве данных

**Функциональные изменения:**
- Автоматический fallback на mock-данные при недоступности OData
- Восстановление координат остановок и генерация расписания при неполных данных
- Кеширование транспортных данных для снижения нагрузки на OData
- Прозрачность для пользователя о происхождении данных

### Новый поток данных

**Старый поток (до интеграции):**
```
BuildRouteUseCase → RouteGraphBuilder → OData Services → OData API → Graph → Response
```

**Новый поток (после интеграции):**
```
BuildRouteUseCase → LoadTransportDataUseCase → TransportDataService → 
  → Provider Selection (OData/Mock) → QualityValidator → 
  → DataRecoveryService (optional) → TransportDataset → Cache → 
  → RouteGraphBuilder → Graph → Response (+ mode + quality)
```

**Ключевые отличия:**
- Загрузка данных отделена от построения графа
- Данные валидируются и при необходимости восстанавливаются
- Результат кешируется на уровне датасета (не графа)
- Клиент получает информацию о режиме и качестве данных

### Компоненты, которые остаются неизменными

**Domain Layer:**
- Сущности IRoute, IStop, IFlight — остаются без изменений
- Интерфейс IRouteBuilderParams — без изменений
- RouteGraph структура — без изменений

**Application Layer:**
- PathFinder — алгоритм поиска маршрутов остаётся прежним
- RiskEngine — оценка рисков не меняется
- Existing use-cases (кроме BuildRouteUseCase) — без изменений

**Infrastructure Layer:**
- OData Services (RoutesService, StopsService, FlightsService) — остаются, используются через ODataTransportProvider
- Existing repositories — без изменений
- Database и MinIO — без изменений

**Presentation Layer:**
- Routing — без изменений
- Middleware — без изменений
- Существующие endpoints (кроме routes) — без изменений

**Frontend:**
- Компоненты отображения маршрутов — остаются без изменений (получают те же данные)
- SearchForm — без изменений
- RouteDetails — расширяется только отображением badge режима

---

## 6.2 Изменения в BuildRouteUseCase

### Добавление новой зависимости

**Текущее состояние:**
BuildRouteUseCase имеет зависимости:
- RouteGraphBuilder — для построения графа
- PathFinder — для поиска маршрутов
- RiskEngine — для оценки рисков
- Logger — для логирования

**Изменение:**
Добавляется новая зависимость LoadTransportDataUseCase для получения транспортных данных.

**Обоснование:**
Следуя принципу Single Responsibility, BuildRouteUseCase не должен заниматься загрузкой данных — это ответственность LoadTransportDataUseCase. BuildRouteUseCase фокусируется только на координации построения маршрута.

**Способ внедрения:**
Через конструктор (Dependency Injection). DI-контейнер создаёт экземпляр LoadTransportDataUseCase и передаёт в BuildRouteUseCase при инициализации.

### Замена старой функции

**Старая логика:**
В начале метода execute BuildRouteUseCase напрямую вызывал RouteGraphBuilder.buildGraph, который внутри себя обращался к OData сервисам.

**Новая логика:**
В начале метода execute BuildRouteUseCase вызывает LoadTransportDataUseCase.execute для получения TransportDataset, затем передаёт этот датасет в RouteGraphBuilder.buildFromDataset.

**Последовательность действий:**
1. Получение параметров поиска (origin, destination, transportTypes, departureTime)
2. Вызов LoadTransportDataUseCase.execute — получение TransportDataset
3. Извлечение mode и quality из датасета для логирования
4. Вызов RouteGraphBuilder.buildFromDataset с датасетом — получение графа
5. Вызов PathFinder для поиска маршрутов в графе
6. Вызов RiskEngine для оценки рисков
7. Формирование IRouteBuilderResult с включением mode и quality

### Работа с TransportDataset

**Получение датасета:**
LoadTransportDataUseCase возвращает объект TransportDataset, содержащий:
- routes — массив маршрутов
- stops — массив остановок
- flights — массив рейсов
- mode — режим источника (REAL/RECOVERY/MOCK)
- quality — показатель качества (0-100)
- loadedAt — время загрузки
- source — имя провайдера

**Использование датасета:**
BuildRouteUseCase не модифицирует датасет, только передаёт его в RouteGraphBuilder. UseCase выступает как координатор потока данных.

**Логирование датасета:**
BuildRouteUseCase логирует информацию о датасете:
- Режим данных (info level для REAL, warn level для RECOVERY/MOCK)
- Показатель качества
- Источник данных
- Время загрузки

### Обработка mode и quality

**Режим REAL:**
- Логируется как info: "Using real transport data, quality: 95"
- Граф строится как обычно
- Никаких дополнительных действий

**Режим RECOVERY:**
- Логируется как warning: "Using recovered transport data, quality: 75"
- Граф строится из восстановленных данных
- В результат добавляется пометка о частичном восстановлении

**Режим MOCK:**
- Логируется как warning: "Using mock transport data, OData unavailable"
- Граф строится из заглушки
- В результат добавляется пометка о демонстрационных данных

**Включение в результат:**
IRouteBuilderResult расширяется полями:
- dataMode — строковое представление режима
- dataQuality — числовой показатель качества

Эти поля передаются клиенту для отображения badge с информацией о данных.

### Что остаётся прежним

**Неизменная логика:**
- Параметры поиска маршрутов — остаются теми же
- Алгоритм PathFinder — без изменений
- Оценка рисков через RiskEngine — без изменений
- Формирование результата IRouteBuilderResult — расширяется, но не ломается
- Обработка ошибок — остаётся на том же уровне

**Гарантии:**
- Существующие тесты на BuildRouteUseCase продолжают работать
- API контракт сохраняется (добавляются только новые опциональные поля)
- Клиенты, не ожидающие новые поля, продолжают работать

---

## 6.3 Изменения в RouteGraphBuilder

### Новая точка входа для построения графа

**Новый метод: buildFromDataset**

**Сигнатура:**
Метод принимает один параметр — TransportDataset. Возвращает RouteGraph.

**Назначение:**
Построить граф маршрутной сети из готового унифицированного датасета вместо прямого обращения к внешним сервисам.

**Преимущества:**
- Разделение ответственности: builder только строит граф, не загружает данные
- Поддержка разных источников данных (OData, mock, будущие провайдеры)
- Возможность тестирования с любыми входными данными
- Независимость от доступности внешних API

**Место вызова:**
Вызывается из BuildRouteUseCase после получения TransportDataset от LoadTransportDataUseCase.

### Интерпретация TransportDataset

**Маршруты (routes):**
Builder извлекает массив маршрутов из dataset.routes. Для каждого маршрута:
- Создаётся логическая группа рёбер графа
- Определяется тип транспорта для расчёта весов
- Используется информация о тарифе для стоимости рёбер

**Остановки (stops):**
Builder извлекает массив остановок из dataset.stops. Для каждой остановки:
- Создаётся узел графа с уникальным ID
- Устанавливаются координаты для геопозиционирования
- Сохраняется название для отображения

**Рейсы (flights):**
Builder извлекает массив рейсов из dataset.flights. Для каждого рейса:
- Создаются временные слои графа (time-expanded graph)
- Рёбра обогащаются информацией о времени отправления
- Формируются возможные пересадки

**Метаданные (mode, quality):**
Builder не использует напрямую, но может логировать для отладки. Метаданные используются на уровне UseCase для формирования ответа клиенту.

### Роль старого метода buildGraph (legacy)

**Старый метод: buildGraph**

**Текущее поведение:**
Внутри метода выполняются прямые вызовы к RoutesService, StopsService, FlightsService для загрузки данных из OData, затем строится граф.

**Почему остаётся:**
- Обратная совместимость с существующим кодом
- Возможность прямого использования в тестах
- Постепенная миграция на новую архитектуру

**Статус:**
Помечается как deprecated (устаревший) в документации и комментариях. Рекомендуется использовать buildFromDataset.

**Будущее:**
После полной миграции всех use-cases на buildFromDataset, метод buildGraph может быть удалён в следующей мажорной версии.

**Внутренняя реализация:**
buildGraph может быть переписан так, что внутри использует ODataTransportProvider для загрузки датасета и затем вызывает buildFromDataset. Это сохраняет API, но унифицирует логику.

### Правила добавления узлов и рёбер

**Создание узлов (nodes):**

**Правило 1: Уникальность узлов**
Каждая остановка из dataset.stops создаёт один узел графа с ID = stop.id. Дублирующие ID игнорируются (берётся первая встреченная остановка).

**Правило 2: Обязательные поля узла**
Узел содержит: ID остановки, название, координаты (широта, долгота). Если координаты отсутствуют — узел создаётся, но помечается как "без геопозиции".

**Правило 3: Группировка близких остановок**
Остановки с координатами, отличающимися менее чем на 50 метров, объединяются в пересадочный узел (transfer node). Это позволяет искать маршруты с пересадками.

**Создание рёбер (edges):**

**Правило 1: Рёбра из последовательности остановок**
Для каждого маршрута извлекается последовательность остановок. Между каждой парой соседних остановок создаётся ребро (directed edge).

**Правило 2: Вес ребра**
Вес ребра рассчитывается как комбинация:
- Времени в пути (по умолчанию: расстояние / средняя скорость типа транспорта)
- Стоимости (тариф маршрута или базовая стоимость)
- Коэффициента комфорта (зависит от типа транспорта)

**Правило 3: Временные слои**
Если для маршрута есть расписание (flights), создаются временные рёбра для каждого рейса. Ребро активно только в определённое время отправления.

**Правило 4: Рёбра пересадок**
Между узлами одного пересадочного узла создаются рёбра пересадки с весом = время пересадки (по умолчанию 5 минут).

**Правило 5: Отсутствующие данные**
Если для ребра отсутствует информация о времени или стоимости — используются значения по умолчанию из конфигурации.

### Влияние пометки данных на построение графа

**Режим REAL:**
- Граф строится со всеми доступными данными
- Используются реальные времена в пути из расписания
- Координаты остановок точные
- Никаких упрощений или аппроксимаций

**Режим RECOVERY:**
- Граф строится из частично восстановленных данных
- Некоторые времена в пути рассчитаны по шаблонам
- Координаты остановок могут быть аппроксимированы
- Рёбра помечаются как "восстановленные" (для отладки)
- Граф может содержать меньше временных слоёв (если расписание сгенерировано)

**Режим MOCK:**
- Граф строится из заглушки
- Все данные полные и корректные (качество 100)
- Ограниченное количество маршрутов и остановок
- Граф оптимизирован для демонстрации функциональности
- Координаты и расписание идеальные

**Практическое влияние:**
Пометка данных не меняет алгоритм построения графа, но влияет на:
- Логирование (разные уровни для разных режимов)
- Отладку (можно фильтровать логи по режиму)
- Мониторинг (метрики строятся отдельно для REAL/RECOVERY/MOCK)
- Пользовательский опыт (клиент видит badge с режимом)

---

## 6.4 Обратная совместимость (Backward Compatibility)

### Как избежать падения старой логики

**Принцип: новый код не должен ломать существующий**

**Стратегия 1: Additive Changes Only**
Все изменения — только добавления. Не удаляются и не модифицируются существующие методы, интерфейсы, сущности. Новая функциональность добавляется параллельно старой.

**Стратегия 2: Опциональные поля**
Новые поля в ответах API (dataMode, dataQuality) делаются опциональными. Клиенты, не ожидающие эти поля, игнорируют их. Клиенты, ожидающие эти поля, получают дополнительную информацию.

**Стратегия 3: Fallback на старую логику**
Если новая система загрузки данных выдаёт ошибку, система автоматически возвращается к старой логике (прямой вызов OData через buildGraph).

**Стратегия 4: Feature Toggle**
Новая система активируется через флаг конфигурации USE_ADAPTIVE_DATA_LOADING. По умолчанию флаг выключен (false). Включается постепенно: сначала на dev, затем staging, затем production.

### Обеспечение работоспособности старого RouteGraphBuilder

**Сохранение метода buildGraph:**
Метод buildGraph остаётся публичным и доступным. Его поведение не меняется: загружает данные из OData и строит граф.

**Параллельное существование методов:**
buildGraph и buildFromDataset существуют параллельно. buildGraph используется legacy кодом и тестами. buildFromDataset используется новым кодом через LoadTransportDataUseCase.

**Рефакторинг buildGraph (опционально):**
buildGraph может быть переписан так, что внутри использует ODataTransportProvider и buildFromDataset. Это унифицирует логику, сохраняя API:
- buildGraph вызывает ODataTransportProvider.loadData
- Получает TransportDataset
- Вызывает buildFromDataset(dataset)
- Возвращает граф

Такой рефакторинг не ломает существующий код, так как сигнатура и поведение buildGraph остаются прежними.

**Тесты на buildGraph:**
Все существующие unit-тесты и integration-тесты на buildGraph продолжают работать без изменений. Это гарантирует, что рефакторинг не вносит регрессии.

### Почему новый метод не ломает legacy клиентов

**API контракт не меняется:**
Существующие endpoints продолжают возвращать тот же формат данных:
- routes — массив маршрутов (без изменений)
- totalDistance, totalDuration, totalCost — без изменений
- riskAssessment — без изменений

**Новые поля опциональны:**
dataMode и dataQuality добавляются в конец ответа. Клиенты, парсящие JSON, игнорируют неизвестные поля по умолчанию. Legacy клиенты получают знакомые данные и продолжают работать.

**HTTP статусы не меняются:**
200 OK для успешных запросов, 400 для некорректных параметров, 500 для серверных ошибок. Логика обработки ошибок остаётся прежней.

**Backward compatible расширение:**
Следуя принципу Open/Closed Principle: система открыта для расширения (новые поля), закрыта для модификации (старые поля не меняются).

### Включение новой системы флагом конфигурации

**Флаг: USE_ADAPTIVE_DATA_LOADING**

**Значения:**
- false (по умолчанию) — используется старая логика (buildGraph)
- true — используется новая логика (LoadTransportDataUseCase + buildFromDataset)

**Место хранения:**
Переменная окружения в файле backend/.env:
```
USE_ADAPTIVE_DATA_LOADING=false
```

**Логика переключения:**
В BuildRouteUseCase проверяется флаг:
- Если флаг false — вызывается routeGraphBuilder.buildGraph
- Если флаг true — вызывается loadTransportDataUseCase.execute + routeGraphBuilder.buildFromDataset

**Преимущества:**
- Включение новой системы без изменения кода (только переменная окружения)
- Возможность быстрого отката при обнаружении проблем
- Постепенное включение на разных окружениях
- A/B тестирование на production (часть запросов через новую систему, часть через старую)

**План включения:**
1. Development: USE_ADAPTIVE_DATA_LOADING=true, тестирование разработчиками
2. Staging: USE_ADAPTIVE_DATA_LOADING=true, QA тестирование
3. Production (5%): A/B тест с 5% трафика на новую систему
4. Production (50%): увеличение до 50% при успехе
5. Production (100%): полное переключение
6. Удаление флага: после стабильной работы 2-4 недели, флаг удаляется, новая система становится единственной

---

## 6.5 Изменения в Presentation Layer

### Изменения в контроллере маршрутов

**Контроллер: RouteBuilderController**

**Текущее состояние:**
Контроллер принимает GET запрос на endpoint /api/v1/routes/search с параметрами: origin, destination, transportTypes, departureTime. Вызывает BuildRouteUseCase.execute. Получает IRouteBuilderResult. Преобразует в JSON и отправляет клиенту.

**Новое состояние:**
Логика остаётся та же, но IRouteBuilderResult теперь содержит дополнительные поля dataMode и dataQuality. Контроллер включает эти поля в JSON ответ.

**Изменения:**
- Расширение типа ответа (добавление полей dataMode и dataQuality)
- Без изменения логики обработки запроса
- Без изменения валидации параметров
- Без изменения обработки ошибок

**Обратная совместимость:**
Существующие клиенты продолжают получать routes, totalDistance, totalDuration, totalCost, riskAssessment. Новые поля dataMode и dataQuality игнорируются legacy клиентами.

### Новые поля в ответе API

**Поле: dataMode**

**Тип:** string  
**Возможные значения:** "real" | "recovery" | "mock"  
**Описание:** Режим источника транспортных данных  
**Когда появляется:** Всегда присутствует в ответе при USE_ADAPTIVE_DATA_LOADING=true

**Интерпретация клиентом:**
- "real" — данные из реального источника, высокое качество
- "recovery" — данные частично восстановлены, среднее качество
- "mock" — демонстрационные данные, OData недоступен

**Поле: dataQuality**

**Тип:** number (integer)  
**Диапазон:** 0-100  
**Описание:** Показатель качества транспортных данных  
**Когда появляется:** Всегда присутствует в ответе при USE_ADAPTIVE_DATA_LOADING=true

**Интерпретация клиентом:**
- 90-100 — отличное качество (зелёный badge)
- 70-89 — хорошее качество (жёлтый badge)
- 50-69 — удовлетворительное качество (оранжевый badge)
- 0-49 — низкое качество (красный badge, fallback на mock)

**Структура ответа (пример):**
```
Ответ содержит:
- routes: массив маршрутов
- totalDistance: число (метры)
- totalDuration: число (секунды)
- totalCost: число (рубли)
- riskAssessment: объект с оценкой рисков
- dataMode: строка ("real" | "recovery" | "mock")
- dataQuality: число (0-100)
```

### Diagnostics Endpoint

**Новый endpoint: GET /api/v1/diagnostics/transport-data**

**Назначение:**
Предоставление информации о состоянии системы загрузки транспортных данных для мониторинга и отладки.

**Возвращаемые данные:**
- currentMode — текущий режим данных (REAL/RECOVERY/MOCK)
- lastLoadTime — время последней загрузки датасета
- quality — показатель качества последнего датасета
- odataAvailable — доступность OData API (boolean)
- cacheStatus — статус кеша (hit/miss/disabled)
- dataSource — имя провайдера (ODataTransportProvider/MockTransportProvider)
- routesCount — количество маршрутов в датасете
- stopsCount — количество остановок в датасете
- flightsCount — количество рейсов в датасете

**Кто использует:**
- DevOps для мониторинга здоровья системы
- Разработчики для отладки проблем с данными
- QA для верификации режимов работы
- Опционально: frontend для отображения статуса системы администратору

**Авторизация:**
Endpoint доступен только администраторам (требуется JWT токен с ролью admin).

**Формат ответа:**
JSON с вышеперечисленными полями. HTTP статус 200 OK при успехе, 500 Internal Server Error при ошибке получения диагностики.

### Отображение режима и качества на frontend

**Компонент: RouteDataModeBadge**

**Назначение:**
Отображение badge с режимом данных и показателем качества рядом с результатами поиска маршрутов.

**Вход:**
Получает dataMode и dataQuality из ответа API /routes/search.

**Отображение по режиму:**

**REAL режим:**
- Badge: зелёный цвет, текст "Актуальные данные"
- Иконка: галочка
- Tooltip: "Данные получены из реального источника, качество: {quality}%"

**RECOVERY режим:**
- Badge: жёлтый цвет, текст "Восстановленные данные"
- Иконка: предупреждение
- Tooltip: "Некоторые данные восстановлены автоматически, качество: {quality}%"

**MOCK режим:**
- Badge: серый цвет, текст "Демонстрационные данные"
- Иконка: информация
- Tooltip: "Реальный источник недоступен, используются демонстрационные данные"

**Расположение:**
Badge отображается над результатами поиска, под формой поиска. При наведении появляется tooltip с подробной информацией.

**Скрытие:**
Если USE_ADAPTIVE_DATA_LOADING=false или dataMode отсутствует в ответе — badge не отображается.

### Избежание обратного несовместимого изменения API

**Принцип: Additive Changes Only**

**Правило 1: Не удалять существующие поля**
Все поля, присутствующие в текущем ответе API, остаются. Никакие поля не переименовываются, не удаляются, не меняют тип.

**Правило 2: Новые поля опциональны**
dataMode и dataQuality — опциональные поля. Клиенты, не проверяющие их наличие, продолжают работать.

**Правило 3: Версионирование API**
Текущая версия API остаётся /api/v1. Изменения backward compatible, поэтому не требуют новой версии. Если в будущем потребуются breaking changes — создаётся /api/v2.

**Правило 4: Документирование изменений**
Все новые поля документируются в API Contracts документе. Указывается, что поля опциональны и доступны только при включённом флаге USE_ADAPTIVE_DATA_LOADING.

**Правило 5: Поддержка старых клиентов**
Гарантия: клиенты, разработанные до внедрения адаптивной загрузки, продолжают работать без изменений минимум 6 месяцев после релиза.

---

## 6.6 Последовательность интеграции (пошагово)

### Шаг 1: Внедрение зависимостей (Dependencies Setup)

**Действия:**
- Добавление новых npm пакетов (если требуются)
- Настройка DI-контейнера для создания LoadTransportDataUseCase
- Настройка DI-контейнера для создания TransportDataService
- Настройка DI-контейнера для создания всех провайдеров и сервисов

**Изменяемые файлы:**
- backend/package.json — добавление зависимостей (если нужны)
- backend/src/infrastructure/di/container.ts — регистрация новых сервисов

**Валидация шага:**
- npm install выполняется без ошибок
- DI-контейнер создаёт экземпляры всех новых классов
- Unit-тесты на DI-контейнер проходят

**Длительность:** 1 час

---

### Шаг 2: Миграция UseCase (UseCase Migration)

**Действия:**
- Добавление LoadTransportDataUseCase в конструктор BuildRouteUseCase
- Добавление флага USE_ADAPTIVE_DATA_LOADING в конфигурацию
- Добавление условной логики выбора между старым и новым путём загрузки данных

**Изменяемые файлы:**
- backend/src/application/route-builder/BuildRouteUseCase.ts — расширение конструктора и метода execute
- backend/.env — добавление USE_ADAPTIVE_DATA_LOADING=false

**Валидация шага:**
- Флаг false — система работает как раньше
- Флаг true — вызывается новая логика
- Существующие тесты на BuildRouteUseCase проходят (флаг false)

**Длительность:** 2 часа

---

### Шаг 3: Подключение TransportDataset (Dataset Integration)

**Действия:**
- Изменение вызова RouteGraphBuilder: с buildGraph на buildFromDataset (при флаге true)
- Передача TransportDataset из LoadTransportDataUseCase в RouteGraphBuilder
- Извлечение mode и quality из датасета для логирования

**Изменяемые файлы:**
- backend/src/application/route-builder/BuildRouteUseCase.ts — изменение вызова builder

**Валидация шага:**
- При флаге false — используется buildGraph
- При флаге true — используется buildFromDataset
- Логи содержат информацию о режиме и качестве данных

**Длительность:** 1 час

---

### Шаг 4: Добавление флагов режима (Mode Flags Integration)

**Действия:**
- Расширение IRouteBuilderResult полями dataMode и dataQuality
- Установка значений этих полей из TransportDataset в BuildRouteUseCase
- Обеспечение, что при флаге false поля остаются пустыми или отсутствуют

**Изменяемые файлы:**
- backend/src/domain/entities/IRouteBuilderResult.ts — добавление полей
- backend/src/application/route-builder/BuildRouteUseCase.ts — установка значений

**Валидация шага:**
- IRouteBuilderResult содержит новые поля (при флаге true)
- Значения корректны (соответствуют режиму из датасета)
- Старые тесты не падают (поля опциональны)

**Длительность:** 1 час

---

### Шаг 5: Адаптация GraphBuilder (GraphBuilder Adaptation)

**Действия:**
- Реализация метода buildFromDataset в RouteGraphBuilder
- Извлечение логики построения узлов и рёбер из датасета
- Обеспечение, что buildGraph остаётся рабочим (legacy поддержка)

**Изменяемые файлы:**
- backend/src/application/route-builder/RouteGraphBuilder.ts — добавление buildFromDataset

**Валидация шага:**
- buildFromDataset строит граф из TransportDataset
- Граф идентичен тому, что строил buildGraph (для одинаковых данных)
- buildGraph продолжает работать

**Длительность:** 4 часа

---

### Шаг 6: Расширение контроллера (Controller Extension)

**Действия:**
- Обеспечение, что RouteBuilderController передаёт dataMode и dataQuality в JSON ответ
- Проверка, что поля присутствуют только при USE_ADAPTIVE_DATA_LOADING=true

**Изменяемые файлы:**
- backend/src/presentation/controllers/RouteBuilderController.ts — расширение формирования ответа

**Валидация шага:**
- Ответ API содержит dataMode и dataQuality (при флаге true)
- Ответ API не содержит этих полей (при флаге false)
- HTTP статусы корректны

**Длительность:** 1 час

---

### Шаг 7: Включение diagnostics (Diagnostics Enablement)

**Действия:**
- Создание DiagnosticsController
- Реализация endpoint GET /api/v1/diagnostics/transport-data
- Добавление middleware для проверки прав доступа (только admin)

**Изменяемые файлы:**
- backend/src/presentation/controllers/DiagnosticsController.ts — новый файл
- backend/src/presentation/routes/index.ts — добавление роута

**Валидация шага:**
- Endpoint доступен для администраторов
- Endpoint возвращает корректную диагностику
- Endpoint недоступен для обычных пользователей (403 Forbidden)

**Длительность:** 2 часа

---

### Шаг 8: Тестирование каждого шага (Step-by-Step Testing)

**Для каждого шага выполняется:**

**Unit тесты:**
- Написание тестов для новых классов и методов
- Запуск существующих тестов для проверки отсутствия регрессий
- Цель: покрытие >= 80%

**Integration тесты:**
- Тестирование взаимодействия между модулями
- Проверка флага USE_ADAPTIVE_DATA_LOADING (false и true)
- Тестирование всех трёх режимов (REAL, RECOVERY, MOCK)

**API тесты:**
- Отправка запросов на /routes/search
- Проверка структуры ответа
- Проверка наличия/отсутствия новых полей в зависимости от флага

**Manual тесты:**
- Запуск backend локально
- Проверка работоспособности через Postman/curl
- Проверка логов на наличие информации о режиме данных

**Длительность тестирования:** 2-4 часа на каждый шаг (параллельно с разработкой)

---

**Общая длительность интеграции:** 12-16 часов (1.5-2 рабочих дня)

---

## 6.7 Сценарии интеграции

### Сценарий 1: OData доступна, качество высокое (REAL режим)

**Условия:**
- OData API доступен и отвечает на запросы
- Данные полные: все маршруты имеют остановки, координаты, расписание
- Показатель качества >= 90

**Выбор режима UseCase:**
- LoadTransportDataUseCase вызывает TransportDataService.loadData
- TransportDataService выбирает ODataTransportProvider (isAvailable = true)
- ODataTransportProvider загружает данные из OData
- QualityValidator оценивает качество: 95/100
- TransportDataService устанавливает mode = REAL
- TransportDataset возвращается в BuildRouteUseCase

**Построение графа GraphBuilder:**
- RouteGraphBuilder.buildFromDataset получает датасет
- Создаются узлы для всех остановок с точными координатами
- Создаются рёбра для всех участков маршрутов
- Интегрируется реальное расписание из flights
- Граф полностью соответствует актуальной транспортной сети
- RouteGraph возвращается в BuildRouteUseCase

**Что отправляется клиенту:**
- routes — найденные маршруты (оптимальные пути)
- totalDistance, totalDuration, totalCost — рассчитаны точно
- riskAssessment — оценка рисков
- dataMode: "real"
- dataQuality: 95
- HTTP статус: 200 OK

**Диагностика (endpoint /diagnostics/transport-data):**
- currentMode: "real"
- lastLoadTime: текущее время
- quality: 95
- odataAvailable: true
- cacheStatus: "miss" (первая загрузка) или "hit" (из кеша)
- dataSource: "ODataTransportProvider"
- routesCount, stopsCount, flightsCount — реальные значения

---

### Сценарий 2: OData доступна, качество среднее (RECOVERY режим)

**Условия:**
- OData API доступен
- Данные частично заполнены: у 30% остановок отсутствуют координаты, расписание есть только для 60% маршрутов
- Показатель качества = 75

**Выбор режима UseCase:**
- LoadTransportDataUseCase вызывает TransportDataService.loadData
- TransportDataService выбирает ODataTransportProvider
- ODataTransportProvider загружает частичные данные
- QualityValidator оценивает качество: 75/100 (coordinatesScore=70, schedulesScore=60)
- TransportDataService определяет: нужно восстановление (50 <= quality < 90)
- TransportDataService вызывает DataRecoveryService.recover
- DataRecoveryService восстанавливает координаты (геокодирование, интерполяция)
- DataRecoveryService генерирует расписание по шаблонам
- QualityValidator повторно оценивает: 85/100
- TransportDataService устанавливает mode = RECOVERY
- TransportDataset (восстановленный) возвращается в BuildRouteUseCase

**Построение графа GraphBuilder:**
- RouteGraphBuilder.buildFromDataset получает восстановленный датасет
- Создаются узлы: часть с реальными координатами, часть с восстановленными
- Создаются рёбра: часть с реальным расписанием, часть с сгенерированным
- Граф полный, но часть данных восстановлена
- RouteGraph возвращается в BuildRouteUseCase

**Что отправляется клиенту:**
- routes — найденные маршруты (могут быть менее точными)
- totalDistance, totalDuration, totalCost — рассчитаны (с учётом восстановленных данных)
- riskAssessment — оценка рисков
- dataMode: "recovery"
- dataQuality: 85
- HTTP статус: 200 OK

**Диагностика:**
- currentMode: "recovery"
- quality: 85
- odataAvailable: true
- dataSource: "ODataTransportProvider (with recovery)"
- Дополнительно: информация о восстановленных полях

---

### Сценарий 3: OData доступна, качество низкое (MOCK fallback)

**Условия:**
- OData API доступен, но возвращает почти пустые данные
- Только 2 маршрута, 10 остановок, без координат и расписания
- Показатель качества = 20

**Выбор режима UseCase:**
- LoadTransportDataUseCase вызывает TransportDataService.loadData
- TransportDataService выбирает ODataTransportProvider
- ODataTransportProvider загружает недостаточные данные
- QualityValidator оценивает качество: 20/100
- TransportDataService определяет: качество критически низкое (< 50)
- TransportDataService вызывает DataRecoveryService.recover (попытка восстановления)
- DataRecoveryService не может восстановить (слишком мало данных)
- QualityValidator повторно оценивает: 30/100 (всё ещё < 50)
- TransportDataService принимает решение: fallback на mock
- TransportDataService вызывает MockTransportProvider.loadData
- MockTransportProvider загружает полные mock-данные
- TransportDataService устанавливает mode = MOCK, quality = 100
- TransportDataset (mock) возвращается в BuildRouteUseCase

**Построение графа GraphBuilder:**
- RouteGraphBuilder.buildFromDataset получает mock-датасет
- Создаются узлы и рёбра из заглушки (полные и корректные)
- Граф ограниченный (только демонстрационные маршруты)
- RouteGraph возвращается в BuildRouteUseCase

**Что отправляется клиенту:**
- routes — найденные маршруты (из mock-данных)
- dataMode: "mock"
- dataQuality: 100 (mock-данные идеальны)
- HTTP статус: 200 OK
- Возможно: дополнительное поле isMockData: true для явного предупреждения

**Диагностика:**
- currentMode: "mock"
- quality: 100
- odataAvailable: true (но данные непригодны)
- dataSource: "MockTransportProvider"
- Примечание: "Fallback due to insufficient OData quality"

---

### Сценарий 4: OData недоступна (MOCK режим)

**Условия:**
- OData API недоступен (timeout, connection refused, 503 Service Unavailable)
- Никакие данные не могут быть загружены из реального источника

**Выбор режима UseCase:**
- LoadTransportDataUseCase вызывает TransportDataService.loadData
- TransportDataService проверяет ODataTransportProvider.isAvailable
- ODataTransportProvider пытается подключиться к OData API
- Соединение не устанавливается (timeout 30 секунд)
- ODataTransportProvider возвращает isAvailable = false
- TransportDataService принимает решение: немедленный fallback на mock (не ждать попыток загрузки)
- TransportDataService вызывает MockTransportProvider.loadData
- MockTransportProvider загружает mock-данные из локальных JSON файлов
- TransportDataService устанавливает mode = MOCK, quality = 100
- TransportDataset (mock) возвращается в BuildRouteUseCase

**Построение графа GraphBuilder:**
- RouteGraphBuilder.buildFromDataset получает mock-датасет
- Создаются узлы и рёбра из заглушки
- Граф полный, но ограниченный по количеству маршрутов
- RouteGraph возвращается в BuildRouteUseCase

**Что отправляется клиенту:**
- routes — найденные маршруты (из mock-данных)
- dataMode: "mock"
- dataQuality: 100
- HTTP статус: 200 OK
- Система работает, несмотря на недоступность OData

**Диагностика:**
- currentMode: "mock"
- quality: 100
- odataAvailable: false
- dataSource: "MockTransportProvider"
- Примечание: "OData unavailable, using mock data"

---

## 6.8 Риски интеграции и их митигация

### Риски на уровне данных

**Риск 1: Некорректное восстановление координат**

**Описание:**
DataRecoveryService может восстановить координаты остановок неверно (например, по ошибочному адресу или интерполяции между далёкими остановками). Это приведёт к построению графа с неточными позициями узлов, что повлияет на расчёт расстояний и времени в пути.

**Вероятность:** Средняя  
**Влияние:** Среднее (неточные маршруты, но система работает)

**Митигация:**
- Валидация восстановленных координат (проверка, что координаты в пределах города)
- Использование fallback на центр города только как крайней меры
- Логирование всех восстановлений для аудита
- Ручная проверка качества восстановленных данных на staging
- Установка порога: если > 50% координат восстановлено — fallback на mock

---

**Риск 2: Несоответствие типов данных между OData и доменными сущностями**

**Описание:**
OData API может вернуть данные в формате, не соответствующем ожиданиям ODataTransportProvider. Например, поле Координаты может быть строкой вместо объекта с lat/lng. Это приведёт к ошибке парсинга и падению системы.

**Вероятность:** Низкая (если API стабилен)  
**Влияние:** Высокое (система падает)

**Митигация:**
- Строгая валидация данных из OData перед преобразованием в доменные сущности
- Try-catch блоки вокруг парсинга с fallback на mock при ошибке
- Unit-тесты с различными форматами входных данных
- Integration-тесты с реальным OData API на staging
- Мониторинг ошибок парсинга с алертами

---

**Риск 3: Устаревание mock-данных**

**Описание:**
Mock-данные подготовлены заранее и не обновляются автоматически. Со временем они устаревают: маршруты изменяются, остановки переименовываются, расписание меняется. Пользователи, видящие mock-данные, получают неактуальную информацию.

**Вероятность:** Высокая (со временем)  
**Влияние:** Среднее (неудобство для пользователей)

**Митигация:**
- Регулярное обновление mock-данных (раз в 3-6 месяцев)
- Явное предупреждение пользователю при режиме MOCK
- Отображение даты последнего обновления mock-данных
- Автоматизация генерации mock-данных из реальных данных (snapshot)

---

### Риски на уровне бизнес-логики

**Риск 4: Изменение алгоритма поиска маршрутов из-за восстановленных данных**

**Описание:**
PathFinder может находить другие маршруты при работе с восстановленными данными по сравнению с реальными. Это может привести к несоответствию ожиданиям пользователей или бизнес-требованиям.

**Вероятность:** Средняя  
**Влияние:** Среднее (изменение результатов)

**Митигация:**
- Тестирование PathFinder с реальными и восстановленными данными, сравнение результатов
- Установка допустимого порога отклонения (например, время в пути может отличаться не более чем на 20%)
- Пометка маршрутов как "приблизительные" при режиме RECOVERY
- A/B тестирование на production для проверки удовлетворённости пользователей

---

**Риск 5: Некорректная оценка рисков из-за неполных данных**

**Описание:**
RiskEngine оценивает риски на основе различных факторов, включая загруженность транспорта, погодные условия, исторические данные. При использовании mock-данных или восстановленных данных оценка рисков может быть неточной.

**Вероятность:** Средняя  
**Влияние:** Среднее (неточная оценка рисков)

**Митигация:**
- Разделение оценки рисков: базовая (всегда) и расширенная (только для REAL режима)
- Понижение уровня уверенности в оценке рисков при режимах RECOVERY и MOCK
- Явное указание клиенту, что оценка рисков приблизительная
- Отключение критичных решений на основе рисков при режиме MOCK

---

### Риски на уровне API

**Риск 6: Breaking change для существующих клиентов**

**Описание:**
Несмотря на попытки обеспечить обратную совместимость, изменения в API могут непредвиденно сломать существующих клиентов (например, если клиент строго валидирует структуру ответа и не допускает дополнительных полей).

**Вероятность:** Низкая  
**Влияние:** Высокое (падение клиентских приложений)

**Митигация:**
- Тщательное тестирование с существующими клиентами на staging
- Использование feature toggle для постепенного включения
- Версионирование API при необходимости breaking changes
- Мониторинг ошибок клиентов после релиза
- Быстрый rollback при обнаружении проблем

---

**Риск 7: Увеличение размера ответа API**

**Описание:**
Добавление новых полей dataMode и dataQuality увеличивает размер ответа. При большом количестве маршрутов в ответе это может замедлить передачу данных и обработку на клиенте.

**Вероятность:** Низкая (поля очень маленькие)  
**Влияние:** Низкое (незначительное увеличение)

**Митигация:**
- Мониторинг размера ответов API
- Сжатие JSON (gzip) на уровне HTTP сервера
- Пагинация результатов при большом количестве маршрутов
- Опциональное включение полей через query параметр (например, ?includeMetadata=true)

---

### Риски на уровне производительности

**Риск 8: Увеличение времени ответа API из-за дополнительных операций**

**Описание:**
Новая логика включает загрузку данных, валидацию качества, возможное восстановление данных. Это добавляет время обработки запроса, что может привести к увеличению latency API.

**Вероятность:** Средняя  
**Влияние:** Среднее (медленный ответ)

**Митигация:**
- Кеширование TransportDataset в Redis (TTL 1 час) — большинство запросов получают данные из кеша
- Параллельная загрузка данных из OData (routes, stops, flights одновременно)
- Оптимизация алгоритмов восстановления (векторизация, использование индексов)
- Мониторинг latency API с установкой SLA (например, 95% запросов < 500ms)
- Timeout для OData запросов (30 секунд) с быстрым fallback на mock

---

**Риск 9: Высокая нагрузка на Redis**

**Описание:**
При активном использовании системы все запросы будут проверять кеш в Redis. Это может создать высокую нагрузку на Redis и привести к его перегрузке.

**Вероятность:** Средняя (при высоком трафике)  
**Влияние:** Среднее (медленный доступ к кешу)

**Митигация:**
- Использование Redis с репликацией (master-slave)
- Настройка eviction policy (LRU) для автоматического удаления старых записей
- Мониторинг производительности Redis (memory usage, connections, latency)
- Graceful degradation: если Redis недоступен — продолжить без кеша
- Использование connection pooling для эффективного использования соединений

---

**Риск 10: Долгая загрузка из OData при первом запросе**

**Описание:**
При первом запросе (cache miss) система загружает все данные из OData, что может занять 10-30 секунд. Пользователь видит долгую загрузку.

**Вероятность:** Высокая (при холодном старте)  
**Влияние:** Среднее (плохой UX)

**Митигация:**
- Предварительный прогрев кеша (warmup): при старте backend автоматически загружает датасет и кеширует
- Асинхронная загрузка в фоне: первый запрос получает mock-данные, загрузка из OData происходит в фоне
- Отображение loading spinner на frontend с информацией о процессе загрузки
- Установка разумного timeout (30 секунд) для OData запросов

---

## 6.9 Готовность к коду

### Части, полностью определённые

**Domain Layer:**
- Сущность TransportDataset — структура определена, поля описаны
- Enum DataSourceMode — значения определены (REAL, RECOVERY, MOCK)
- Интерфейс ITransportDataProvider — методы определены (loadData, isAvailable)
- Сущность QualityReport — структура определена, поля описаны
- Расширение IRouteBuilderResult — новые поля dataMode и dataQuality определены

**Application Layer:**
- LoadTransportDataUseCase — роль, входы, выходы, зависимости определены
- TransportDataService — методы, логика, алгоритмы определены
- DataRecoveryService — алгоритмы восстановления описаны
- QualityValidator — критерии оценки, формулы определены
- Изменения в BuildRouteUseCase — последовательность действий описана
- Изменения в RouteGraphBuilder — новый метод buildFromDataset определён

**Infrastructure Layer:**
- ODataTransportProvider — логика загрузки, преобразования определена
- MockTransportProvider — логика загрузки mock-данных определена
- DatasetCacheRepository — методы работы с Redis определены

**Presentation Layer:**
- Изменения в RouteBuilderController — расширение ответа определено
- DiagnosticsController — endpoint и возвращаемые данные определены

### Готовность к реализации

**Полностью готовые модули (можно начинать кодирование):**

1. **Domain Entities:**
   - TransportDataset.ts — создание интерфейса с полями
   - DataSourceMode.ts — создание enum
   - QualityReport.ts — создание интерфейса

2. **Domain Interfaces:**
   - ITransportDataProvider.ts — создание интерфейса с методами

3. **Mock Data:**
   - Подготовка JSON файлов с mock-данными (routes.json, stops.json, flights.json)

4. **Configuration:**
   - Добавление переменных окружения в backend/.env

**Модули, требующие последовательной реализации:**

1. **Сначала:** MockTransportProvider (простейший провайдер, работает с локальными файлами)
2. **Затем:** DatasetCacheRepository (простой wrapper над Redis)
3. **Затем:** QualityValidator (валидация данных, расчёт показателя качества)
4. **Затем:** ODataTransportProvider (сложный провайдер, работает с OData API)
5. **Затем:** DataRecoveryService (восстановление данных, зависит от QualityValidator)
6. **Затем:** TransportDataService (оркестратор, зависит от всех провайдеров и сервисов)
7. **Затем:** LoadTransportDataUseCase (use-case, зависит от TransportDataService)
8. **Затем:** Изменения в BuildRouteUseCase и RouteGraphBuilder
9. **Наконец:** Изменения в RouteBuilderController и DiagnosticsController

### Точка входа для первого написанного файла

**Рекомендуемая точка входа:**

**Файл:** `backend/src/domain/entities/TransportDataset.ts`

**Обоснование:**
- Простой файл (только определение интерфейса)
- Не имеет зависимостей от других модулей
- Будет использоваться всеми последующими модулями
- Можно написать и протестировать изолированно

**Структура файла:**
```
Интерфейс TransportDataset содержит:
- routes: массив IRoute
- stops: массив IStop
- flights: массив IFlight
- mode: DataSourceMode
- quality: number (0-100)
- loadedAt: Date
- source: string
```

**Следующий файл:** `backend/src/domain/enums/DataSourceMode.ts` (enum с тремя значениями)

### Шаги, которые можно начинать в VSCode

**Шаг 1: Создание структуры директорий**

Создать новые директории для модулей:
```
backend/src/domain/entities/ — создать TransportDataset.ts, QualityReport.ts
backend/src/domain/enums/ — создать DataSourceMode.ts
backend/src/domain/repositories/ — создать ITransportDataProvider.ts
backend/src/application/data-loading/ — создать TransportDataService.ts, DataRecoveryService.ts, QualityValidator.ts
backend/src/application/use-cases/ — создать LoadTransportDataUseCase.ts
backend/src/infrastructure/data-providers/ — создать ODataTransportProvider.ts, MockTransportProvider.ts
backend/src/infrastructure/cache/ — создать DatasetCacheRepository.ts
backend/data/mock/ — создать routes.json, stops.json, flights.json
```

**Шаг 2: Написание Domain Entities**

Открыть файл `backend/src/domain/entities/TransportDataset.ts` и определить интерфейс согласно спецификации из LLD документа.

Открыть файл `backend/src/domain/enums/DataSourceMode.ts` и определить enum со значениями REAL, RECOVERY, MOCK.

Открыть файл `backend/src/domain/entities/QualityReport.ts` и определить интерфейс с полями для отчёта о качестве.

**Шаг 3: Написание Domain Interfaces**

Открыть файл `backend/src/domain/repositories/ITransportDataProvider.ts` и определить интерфейс с методами loadData и isAvailable.

**Шаг 4: Подготовка Mock Data**

Создать файлы `backend/data/mock/routes.json`, `stops.json`, `flights.json` с подготовленными демонстрационными данными.

**Шаг 5: Написание первого провайдера**

Открыть файл `backend/src/infrastructure/data-providers/MockTransportProvider.ts` и реализовать класс, загружающий данные из JSON файлов.

**Шаг 6: Написание unit-тестов**

Создать файл `backend/src/infrastructure/data-providers/MockTransportProvider.test.ts` и написать тесты для MockTransportProvider.

**Шаг 7: Запуск тестов**

Выполнить команду `npm test` для проверки, что MockTransportProvider работает корректно.

**Шаг 8: Продолжение по списку модулей**

Последовательно реализовывать модули согласно списку в разделе "Готовность к реализации", после каждого модуля писать тесты и запускать их.

---

**Интеграция полностью спроектирована и готова к кодированию.**

**Следующий шаг:** Создание Domain Entities и начало реализации MockTransportProvider.

