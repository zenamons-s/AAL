# ЧАСТЬ 5: Low-Level Design — Вариант B (Средняя сложность)

**Дата:** 2024-11-18  
**Версия:** 1.0  
**Статус:** Draft — Implementation Ready  
**Архитектурный вариант:** B (Medium Complexity)

---

## Содержание

- [5.1 Детальное описание модулей](#51-детальное-описание-модулей-lld-overview)
- [5.2 Структура классов и интерфейсов](#52-структура-классов-и-интерфейсов-текстовое-uml-описание)
- [5.3 Пошаговый псевдоалгоритм работы модулей](#53-пошаговый-псевдоалгоритм-работы-модулей)
- [5.4 Алгоритм выбора режима источника данных](#54-алгоритм-выбора-режима-источника-данных)
- [5.5 Декомпозиция файлов и модулей](#55-декомпозиция-файлов-и-модулей)
- [5.6 Поток интеграции с BuildRouteUseCase](#56-поток-интеграции-с-buildrouteusecase)
- [5.7 Диаграмма последовательности (словесная)](#57-диаграмма-последовательности-словесная)
- [5.8 Краткое резюме для CTO](#58-краткое-резюме-для-cto)

---

## 5.1 Детальное описание модулей (LLD Overview)

### 5.1.1 LoadTransportDataUseCase

**Роль в системе:**  
Точка входа для загрузки транспортных данных. Отвечает за координацию процесса получения данных из внешних источников.

**Входы:**  
Отсутствуют (вызывается без параметров при необходимости загрузки данных).

**Выходы:**  
Объект TransportDataset с полями: маршруты, остановки, рейсы, режим источника данных, показатель качества.

**Ответственность:**
- Делегирует загрузку данных в TransportDataService
- Обрабатывает возможные ошибки загрузки
- Логирует процесс загрузки данных
- Возвращает готовый датасет для построения графа

**Зависимости:**
- TransportDataService — основной сервис загрузки
- Logger — для логирования операций

**Точка вызова:**  
Вызывается из BuildRouteUseCase перед построением графа маршрутов.

---

### 5.1.2 TransportDataService

**Роль в системе:**  
Центральный оркестратор загрузки транспортных данных. Управляет выбором провайдера, валидацией качества и применением восстановления данных.

**Входы:**  
Отсутствуют прямые параметры (использует конфигурацию системы).

**Выходы:**  
TransportDataset — унифицированный набор данных с метаинформацией о качестве и режиме.

**Ответственность:**
- Выбор подходящего провайдера данных (OData или Mock)
- Проверка доступности OData API
- Загрузка данных через выбранный провайдер
- Валидация качества полученных данных
- Принятие решения о применении восстановления
- Вызов DataRecoveryService при необходимости
- Кеширование результата в Redis
- Установка режима источника данных (REAL/RECOVERY/MOCK)

**Зависимости:**
- ITransportDataProvider (интерфейс) — для получения данных
- ODataTransportProvider — реализация для OData
- MockTransportProvider — реализация для mock-данных
- DataRecoveryService — для восстановления данных
- DatasetCacheRepository — для кеширования
- QualityValidator — для оценки качества
- Logger — для логирования

**Точка вызова:**  
Вызывается из LoadTransportDataUseCase.

---

### 5.1.3 DataRecoveryService

**Роль в системе:**  
Восстанавливает недостающие или некорректные данные в транспортном датасете.

**Входы:**
- TransportDataset — исходный датасет с неполными данными
- QualityReport — отчет о качестве с указанием проблемных мест

**Выходы:**
- TransportDataset — восстановленный датасет с заполненными пробелами

**Ответственность:**
- Восстановление координат остановок (по геокодированию, соседним остановкам, шаблонам)
- Генерация расписания рейсов (по типовым шаблонам времени отправления)
- Заполнение недостающих имён остановок (по координатам, номерам маршрутов)
- Установка тарифов по умолчанию для маршрутов
- Генерация идентификаторов для объектов без ID
- Логирование всех восстановлений

**Зависимости:**
- GeocodeService — для получения координат по адресам
- ScheduleTemplateRepository — для типовых расписаний
- Logger — для логирования восстановлений

**Точка вызова:**  
Вызывается из TransportDataService когда показатель качества в диапазоне 50-89.

---

### 5.1.4 ODataTransportProvider

**Роль в системе:**  
Реализация ITransportDataProvider для загрузки данных из OData API.

**Входы:**  
Отсутствуют (использует конфигурацию OData из переменных окружения).

**Выходы:**  
TransportDataset — данные из OData в унифицированном формате.

**Ответственность:**
- Проверка доступности OData API (метод isAvailable)
- Загрузка маршрутов из Catalog_Маршруты
- Загрузка остановок из Catalog_Остановки
- Загрузка расписания из Catalog_РейсыРасписания
- Загрузка таблиц остановок маршрутов (например, Автобус1_Остановки)
- Преобразование OData-структур в доменные сущности (IRoute, IStop, IFlight)
- Обработка ошибок соединения и таймаутов
- Retry-логика для повторных попыток

**Зависимости:**
- RoutesService — для работы с маршрутами OData
- StopsService — для работы с остановками OData
- FlightsService — для работы с расписанием OData
- ODataClient — низкоуровневый HTTP-клиент
- Logger — для логирования

**Точка вызова:**  
Создается и вызывается из TransportDataService при доступности OData.

---

### 5.1.5 MockTransportProvider

**Роль в системе:**  
Реализация ITransportDataProvider для загрузки mock-данных из JSON-файлов.

**Входы:**  
Отсутствуют (использует путь к mock-данным из конфигурации).

**Выходы:**  
TransportDataset — заранее подготовленные данные в унифицированном формате.

**Ответственность:**
- Всегда возвращает true в методе isAvailable (fallback всегда доступен)
- Загрузка маршрутов из mock-файлов
- Загрузка остановок из mock-файлов
- Загрузка расписания из mock-файлов
- Преобразование JSON в доменные сущности
- Установка качества датасета как 100 (mock-данные полные)

**Зависимости:**
- MockDataLoader — для чтения JSON-файлов
- Logger — для логирования

**Точка вызова:**  
Создается и вызывается из TransportDataService при недоступности OData или низком качестве данных.

---

### 5.1.6 DatasetCacheRepository

**Роль в системе:**  
Управляет кешированием загруженных транспортных датасетов в Redis.

**Входы (метод set):**
- ключ — идентификатор кеша (например, "transport-dataset")
- dataset — TransportDataset для сохранения
- ttl — время жизни кеша в секундах

**Входы (метод get):**
- ключ — идентификатор кеша

**Выходы:**
- TransportDataset или null (если кеш пуст или устарел)

**Ответственность:**
- Сохранение датасета в Redis с указанным TTL
- Извлечение датасета из Redis
- Сериализация и десериализация датасета
- Обработка ошибок Redis (graceful degradation)
- Инвалидация кеша по истечении TTL

**Зависимости:**
- RedisClient — для работы с Redis
- Logger — для логирования операций кеша

**Точка вызова:**  
Вызывается из TransportDataService для проверки кеша перед загрузкой и сохранения после загрузки.

---

### 5.1.7 QualityValidator

**Роль в системы:**  
Оценивает качество загруженного транспортного датасета по множеству критериев.

**Входы:**  
TransportDataset — датасет для валидации.

**Выходы:**  
QualityReport — объект с полями:
- overallScore (0-100) — общий показатель качества
- routesScore — процент корректных маршрутов
- stopsScore — процент корректных остановок
- coordinatesScore — процент остановок с координатами
- schedulesScore — процент рейсов с расписанием
- missingFields — список недостающих полей
- recommendations — рекомендации по улучшению

**Ответственность:**
- Проверка наличия маршрутов (минимум 1)
- Проверка наличия остановок (минимум 2)
- Проверка координат у остановок (широта и долгота в допустимых диапазонах)
- Проверка расписания (наличие рейсов для маршрутов)
- Проверка обязательных полей (ID, названия, коды)
- Расчет общего показателя качества (взвешенная сумма)
- Формирование списка рекомендаций

**Зависимости:**
- Logger — для логирования результатов валидации

**Точка вызова:**  
Вызывается из TransportDataService после загрузки данных провайдером.

---

### 5.1.8 RouteGraphBuilder (в части buildFromDataset)

**Роль в системе:**  
Строит граф маршрутной сети из транспортного датасета.

**Входы:**  
TransportDataset — унифицированный набор транспортных данных.

**Выходы:**  
RouteGraph — граф с узлами (остановки) и рёбрами (участки маршрутов).

**Ответственность (новый метод buildFromDataset):**
- Создание узлов графа для каждой остановки из датасета
- Создание рёбер графа для каждого участка маршрута (остановка A → остановка B)
- Расчет веса рёбер (время в пути, стоимость, комфорт)
- Группировка остановок по геопозиции (для пересадок)
- Создание пересадочных узлов (transfer nodes)
- Валидация связности графа
- Индексация графа для быстрого поиска

**Зависимости:**
- PathFinder — для валидации связности
- Logger — для логирования построения графа

**Точка вызова:**  
Вызывается из BuildRouteUseCase после получения TransportDataset.

---

## 5.2 Структура классов и интерфейсов (текстовое UML-описание)

### Интерфейс: ITransportDataProvider

**Назначение:** Контракт для всех провайдеров транспортных данных.

**Свойства:** Отсутствуют.

**Публичные методы:**
- loadData — возвращает Promise с TransportDataset
- isAvailable — возвращает Promise с boolean (доступен ли источник данных)

**События:** Отсутствуют.

---

### Сущность: TransportDataset

**Назначение:** Унифицированная структура транспортных данных.

**Свойства:**
- routes — массив объектов IRoute (маршруты)
- stops — массив объектов IStop (остановки)
- flights — массив объектов IFlight (рейсы по расписанию)
- mode — значение DataSourceMode (REAL/RECOVERY/MOCK)
- quality — число от 0 до 100 (показатель качества)
- loadedAt — дата и время загрузки
- source — строка с именем источника данных

**Публичные методы:** Отсутствуют (это data transfer object).

**События:** Отсутствуют.

---

### Перечисление: DataSourceMode

**Назначение:** Режимы источника данных.

**Значения:**
- REAL — данные из реального источника (OData) без восстановления
- RECOVERY — данные из OData с применением восстановления
- MOCK — данные из mock-файлов (fallback)

---

### Класс: LoadTransportDataUseCase

**Назначение:** Use-case для загрузки транспортных данных.

**Свойства:**
- transportDataService — экземпляр TransportDataService
- logger — экземпляр Logger

**Публичные методы:**
- execute — загружает данные через TransportDataService, обрабатывает ошибки, возвращает TransportDataset

**Вызывает:**
- TransportDataService.loadData
- Logger.info, Logger.error

**События:**
- TransportDataLoadStarted — начало загрузки
- TransportDataLoadCompleted — успешная загрузка
- TransportDataLoadFailed — ошибка загрузки

---

### Класс: TransportDataService

**Назначение:** Центральный сервис управления загрузкой данных.

**Свойства:**
- odataProvider — экземпляр ODataTransportProvider
- mockProvider — экземпляр MockTransportProvider
- recoveryService — экземпляр DataRecoveryService
- cacheRepository — экземпляр DatasetCacheRepository
- qualityValidator — экземпляр QualityValidator
- logger — экземпляр Logger
- config — объект конфигурации (пороги качества, TTL кеша)

**Публичные методы:**
- loadData — главный метод загрузки с логикой выбора провайдера
- invalidateCache — сбрасывает кеш датасета
- getLastLoadInfo — возвращает информацию о последней загрузке

**Приватные методы (логика):**
- selectProvider — выбирает ODataProvider или MockProvider
- shouldRecover — определяет нужно ли восстановление по показателю качества
- applyRecovery — применяет DataRecoveryService к датасету
- setDatasetMode — устанавливает режим REAL/RECOVERY/MOCK

**Вызывает:**
- DatasetCacheRepository.get, set
- ODataTransportProvider.isAvailable, loadData
- MockTransportProvider.loadData
- QualityValidator.validate
- DataRecoveryService.recover
- Logger.info, Logger.warn, Logger.error

**События:**
- ProviderSelected — выбран провайдер
- DataLoaded — данные загружены
- QualityAssessed — качество оценено
- RecoveryApplied — применено восстановление
- DataCached — данные закешированы

---

### Класс: DataRecoveryService

**Назначение:** Восстановление недостающих данных.

**Свойства:**
- geocodeService — экземпляр GeocodeService
- scheduleTemplates — репозиторий шаблонов расписаний
- logger — экземпляр Logger

**Публичные методы:**
- recover — принимает TransportDataset и QualityReport, возвращает восстановленный TransportDataset
- recoverCoordinates — восстанавливает координаты остановок
- recoverSchedules — генерирует расписание рейсов
- fillMissingNames — заполняет недостающие названия

**Вызывает:**
- GeocodeService.getCoordinatesByAddress
- ScheduleTemplateRepository.getTemplate
- Logger.info, Logger.warn

**События:**
- CoordinatesRecovered — координаты восстановлены
- SchedulesGenerated — расписание сгенерировано
- NamesFilledIn — названия заполнены

---

### Класс: ODataTransportProvider

**Назначение:** Провайдер данных из OData API.

**Свойства:**
- routesService — экземпляр RoutesService
- stopsService — экземпляр StopsService
- flightsService — экземпляр FlightsService
- odataClient — экземпляр ODataClient
- logger — экземпляр Logger
- config — OData конфигурация (URL, credentials, timeout)

**Публичные методы:**
- loadData — загружает данные из OData, преобразует в TransportDataset
- isAvailable — проверяет доступность OData API (ping endpoint)

**Приватные методы:**
- aggregateODataCalls — выполняет параллельные запросы к OData
- transformToDataset — преобразует OData-структуры в TransportDataset
- retryRequest — повторяет запрос при ошибке

**Вызывает:**
- RoutesService.getAllRoutes
- StopsService.getAllStops
- FlightsService.getAllFlights
- ODataClient.get
- Logger.info, Logger.error

**События:**
- ODataConnectionOpened — соединение с OData открыто
- ODataDataFetched — данные получены
- ODataConnectionFailed — соединение не удалось

---

### Класс: MockTransportProvider

**Назначение:** Провайдер mock-данных из JSON.

**Свойства:**
- mockDataLoader — экземпляр MockDataLoader
- logger — экземпляр Logger
- mockDataPath — путь к директории с mock-файлами

**Публичные методы:**
- loadData — загружает mock-данные, возвращает TransportDataset
- isAvailable — всегда возвращает true

**Вызывает:**
- MockDataLoader.loadRoutes
- MockDataLoader.loadStops
- MockDataLoader.loadFlights
- Logger.info

**События:**
- MockDataLoaded — mock-данные загружены

---

### Класс: DatasetCacheRepository

**Назначение:** Кеширование датасетов в Redis.

**Свойства:**
- redisClient — экземпляр RedisClient
- logger — экземпляр Logger
- defaultTTL — TTL по умолчанию (3600 секунд)

**Публичные методы:**
- get — получает датасет из кеша по ключу
- set — сохраняет датасет в кеш с TTL
- invalidate — удаляет датасет из кеша
- exists — проверяет наличие датасета в кеше

**Вызывает:**
- RedisClient.get, set, del, exists
- Logger.info, Logger.warn

**События:**
- CacheHit — датасет найден в кеше
- CacheMiss — датасет не найден в кеше
- CacheSet — датасет сохранён в кеше

---

### Класс: QualityValidator

**Назначение:** Валидация качества транспортных данных.

**Свойства:**
- logger — экземпляр Logger
- thresholds — пороговые значения для оценки качества

**Публичные методы:**
- validate — принимает TransportDataset, возвращает QualityReport

**Приватные методы:**
- validateRoutes — проверяет маршруты (наличие, корректность ID)
- validateStops — проверяет остановки
- validateCoordinates — проверяет координаты остановок
- validateSchedules — проверяет расписание рейсов
- calculateOverallScore — вычисляет общий показатель (взвешенная сумма)

**Вызывает:**
- Logger.info, Logger.warn

**События:**
- ValidationStarted — начало валидации
- ValidationCompleted — валидация завершена

---

### Сущность: QualityReport

**Назначение:** Отчет о качестве датасета.

**Свойства:**
- overallScore — общий показатель (0-100)
- routesScore — процент корректных маршрутов
- stopsScore — процент корректных остановок
- coordinatesScore — процент остановок с координатами
- schedulesScore — процент рейсов с расписанием
- missingFields — массив строк с недостающими полями
- recommendations — массив строк с рекомендациями
- validatedAt — дата и время валидации

**Публичные методы:** Отсутствуют (DTO).

---

## 5.3 Пошаговый псевдоалгоритм работы модулей

### Алгоритм работы TransportDataService.loadData

**Шаг 1: Проверка кеша**
- Обратиться к DatasetCacheRepository для получения закешированного датасета
- Если датасет найден и не устарел — вернуть его немедленно
- Если кеш пуст — продолжить загрузку

**Шаг 2: Выбор провайдера данных**
- Попытаться проверить доступность ODataTransportProvider методом isAvailable
- Если OData доступен — использовать ODataTransportProvider
- Если OData недоступен (timeout, connection error) — использовать MockTransportProvider
- Логировать выбранный провайдер

**Шаг 3: Загрузка данных**
- Вызвать метод loadData выбранного провайдера
- Провайдер возвращает TransportDataset с маршрутами, остановками, рейсами
- Обработать возможные ошибки загрузки
- При ошибке загрузки через OData — fallback на MockTransportProvider

**Шаг 4: Оценка качества данных**
- Передать загруженный датасет в QualityValidator
- Получить QualityReport с показателем качества от 0 до 100
- Логировать результаты валидации

**Шаг 5: Принятие решения о режиме**
- Если качество >= 90 и источник OData — установить режим REAL
- Если качество от 50 до 89 и источник OData — установить режим RECOVERY
- Если качество < 50 или источник Mock — установить режим MOCK
- Если режим RECOVERY — перейти к восстановлению
- Если режим REAL или MOCK — перейти к кешированию

**Шаг 6: Применение восстановления (если режим RECOVERY)**
- Вызвать DataRecoveryService.recover с датасетом и отчетом о качестве
- Получить восстановленный датасет
- Повторно оценить качество восстановленного датасета
- Логировать результаты восстановления

**Шаг 7: Fallback на Mock (если восстановление не помогло)**
- Если после восстановления качество всё ещё < 50 — переключиться на MockTransportProvider
- Загрузить mock-данные
- Установить режим MOCK
- Продолжить с mock-датасетом

**Шаг 8: Установка метаданных**
- Установить поле mode датасета (REAL/RECOVERY/MOCK)
- Установить поле quality (финальный показатель качества)
- Установить loadedAt (текущее время)
- Установить source (имя провайдера)

**Шаг 9: Кеширование результата**
- Сохранить итоговый датасет в DatasetCacheRepository с TTL 3600 секунд
- Логировать успешное кеширование

**Шаг 10: Возврат результата**
- Вернуть готовый TransportDataset с установленными метаданными

---

### Алгоритм работы DataRecoveryService.recover

**Шаг 1: Анализ отчета о качестве**
- Изучить QualityReport для определения проблемных областей
- Определить приоритеты восстановления по критичности

**Шаг 2: Восстановление координат остановок**
- Для каждой остановки без координат:
  - Попытаться получить координаты через GeocodeService по адресу
  - Если адрес отсутствует — использовать координаты соседних остановок на том же маршруте
  - Если нет соседних остановок — использовать центр города из конфигурации
  - Логировать каждое восстановление

**Шаг 3: Генерация расписания**
- Для маршрутов без расписания:
  - Выбрать шаблон расписания по типу транспорта (автобус, троллейбус)
  - Применить типовые интервалы (утренний час пик, день, вечер)
  - Создать рейсы с временем отправления по шаблону
  - Установить длительность поездки по умолчанию
  - Логировать генерацию расписания

**Шаг 4: Заполнение названий остановок**
- Для остановок без названий:
  - Попробовать получить название через reverse geocoding по координатам
  - Если не удалось — использовать формат "Остановка №[номер]"
  - Логировать заполнение

**Шаг 5: Установка тарифов по умолчанию**
- Для маршрутов без тарифов:
  - Установить базовый тариф из конфигурации по типу транспорта
  - Логировать установку

**Шаг 6: Генерация идентификаторов**
- Для объектов без ID:
  - Сгенерировать UUID
  - Присвоить объекту
  - Логировать генерацию

**Шаг 7: Валидация восстановленного датасета**
- Проверить что все критичные поля заполнены
- Убедиться что координаты в допустимых диапазонах
- Проверить связность данных (маршруты ссылаются на существующие остановки)

**Шаг 8: Возврат результата**
- Вернуть восстановленный TransportDataset

---

### Алгоритм работы ODataTransportProvider.loadData

**Шаг 1: Параллельная загрузка данных**
- Запустить одновременно три запроса:
  - RoutesService.getAllRoutes — загрузка маршрутов
  - StopsService.getAllStops — загрузка остановок
  - FlightsService.getAllFlights — загрузка расписания
- Установить timeout для каждого запроса (30 секунд)
- Ожидать завершения всех запросов

**Шаг 2: Обработка ошибок запросов**
- Если любой запрос завершился с ошибкой:
  - Попытаться повторить запрос (до 3 раз с задержкой)
  - Если повторные попытки не помогли — логировать ошибку
  - Продолжить с частичными данными

**Шаг 3: Загрузка таблиц остановок маршрутов**
- Для каждого загруженного маршрута:
  - Определить имя таблицы остановок (например, "Автобус1_Остановки")
  - Загрузить записи из этой таблицы
  - Связать остановки с маршрутом

**Шаг 4: Преобразование OData-структур в доменные сущности**
- Преобразовать OData-маршруты в массив IRoute:
  - Извлечь поля: Ref_Key → id, Наименование → name, НомерМаршрута → routeNumber
  - Определить тип транспорта по префиксу
- Преобразовать OData-остановки в массив IStop:
  - Извлечь поля: Ref_Key → id, Наименование → name, Координаты → lat/lng
- Преобразовать OData-расписание в массив IFlight:
  - Извлечь поля: Маршрут_Key → routeId, ВремяОтправления → departureTime

**Шаг 5: Формирование TransportDataset**
- Создать объект TransportDataset
- Заполнить поля routes, stops, flights
- Установить mode = null (будет установлен в TransportDataService)
- Установить quality = null (будет рассчитан в QualityValidator)
- Установить source = "OData"

**Шаг 6: Возврат датасета**
- Вернуть сформированный TransportDataset

---

### Алгоритм работы QualityValidator.validate

**Шаг 1: Валидация маршрутов**
- Проверить что массив routes не пустой
- Подсчитать процент маршрутов с заполненными обязательными полями (id, name, routeNumber)
- Установить routesScore

**Шаг 2: Валидация остановок**
- Проверить что массив stops не пустой
- Проверить минимальное количество (>= 2)
- Подсчитать процент остановок с заполненными полями (id, name)
- Установить stopsScore

**Шаг 3: Валидация координат**
- Подсчитать процент остановок с координатами
- Проверить что координаты в допустимых диапазонах (широта -90..90, долгота -180..180)
- Установить coordinatesScore

**Шаг 4: Валидация расписания**
- Подсчитать процент маршрутов, для которых есть хотя бы один рейс
- Проверить корректность времени отправления
- Установить schedulesScore

**Шаг 5: Расчет общего показателя**
- Рассчитать взвешенную сумму:
  - overallScore = (routesScore × 0.3) + (stopsScore × 0.2) + (coordinatesScore × 0.3) + (schedulesScore × 0.2)
- Округлить до целого числа

**Шаг 6: Формирование рекомендаций**
- Если coordinatesScore < 70 — добавить рекомендацию "Восстановить координаты остановок"
- Если schedulesScore < 50 — добавить рекомендацию "Сгенерировать расписание"
- Если routesScore < 90 — добавить рекомендацию "Проверить обязательные поля маршрутов"

**Шаг 7: Создание отчета**
- Создать объект QualityReport со всеми заполненными полями
- Установить validatedAt (текущее время)
- Вернуть отчет

---

## 5.4 Алгоритм выбора режима источника данных

### Критерии принятия решения

**Режим REAL (реальные данные без восстановления):**

**Условия применения:**
- OData API доступен (isAvailable возвращает true)
- Показатель качества >= 90
- Все критические поля заполнены (маршруты, остановки, координаты)
- Расписание присутствует минимум для 80% маршрутов

**Преимущества:**
- Актуальные данные из реального источника
- Полная информация без искажений
- Высокая точность координат и расписания

**Использование:**
- Прямая передача данных в RouteGraphBuilder
- Кеширование на 1 час

---

**Режим RECOVERY (восстановление недостающих данных):**

**Условия применения:**
- OData API доступен
- Показатель качества от 50 до 89
- Критические поля частично заполнены
- Возможно восстановление недостающих данных

**Критерии качества, влияющие на решение:**
- coordinatesScore < 70 — требуется восстановление координат
- schedulesScore < 70 — требуется генерация расписания
- routesScore >= 80 — основные данные корректны
- stopsScore >= 80 — достаточно остановок

**Процесс восстановления:**
1. Вызов DataRecoveryService.recover
2. Восстановление координат (геокодирование, интерполяция)
3. Генерация расписания по шаблонам
4. Заполнение названий
5. Повторная валидация

**Fallback правило:**
- Если после восстановления качество всё ещё < 50 — переключение на режим MOCK

**Использование:**
- Передача восстановленных данных в RouteGraphBuilder
- Кеширование на 1 час
- Пометка маршрутов как "частично восстановленные"

---

**Режим MOCK (заглушка с подготовленными данными):**

**Условия применения:**
- OData API недоступен (timeout, connection refused, authentication error)
- Показатель качества < 50 (даже после восстановления)
- Критические данные отсутствуют (нет маршрутов или остановок)
- Невозможность восстановления

**Источник данных:**
- Заранее подготовленные JSON-файлы
- Полностью заполненные данные (routes, stops, flights, coordinates)
- Качество mock-данных = 100

**Преимущества:**
- Система работает даже без внешнего API
- Гарантированная доступность
- Быстрая загрузка (из локальных файлов)

**Недостатки:**
- Данные могут быть устаревшими
- Не отражают актуальное расписание
- Ограниченный набор маршрутов

**Использование:**
- Передача mock-данных в RouteGraphBuilder
- Кеширование на 1 час
- Пометка маршрутов как "демонстрационные"

---

### Матрица принятия решения

| OData доступен | Качество | Решение | Действия |
|----------------|----------|---------|----------|
| ✅ Да | >= 90 | REAL | Использовать как есть |
| ✅ Да | 50-89 | RECOVERY | Восстановить недостающие данные |
| ✅ Да | < 50 | RECOVERY → MOCK | Попытаться восстановить, fallback на mock |
| ❌ Нет | N/A | MOCK | Использовать заглушку |

---

### Параметры качества, влияющие на решение

**Критичные параметры (блокируют REAL):**
- routesScore < 80 — недостаточно корректных маршрутов
- stopsScore < 80 — недостаточно остановок
- coordinatesScore < 50 — критическая нехватка координат

**Параметры, требующие восстановления:**
- coordinatesScore 50-70 — частичное отсутствие координат
- schedulesScore < 70 — недостаточно расписания
- Отсутствие названий у > 20% остановок

**Некритичные параметры (допустимы в REAL):**
- Отсутствие тарифов (можно установить по умолчанию)
- Отсутствие описаний маршрутов
- Отсутствие информации о типе транспорта (можно определить эвристически)

---

### Fallback правила

**Правило 1: Каскадное переключение**
- Попытка OData → при неудаче Recovery → при неудаче Mock
- Каждый уровень логируется

**Правило 2: Timeout escalation**
- OData timeout > 30 секунд — немедленное переключение на Mock
- Не ожидать окончания всех retry-попыток

**Правило 3: Graceful degradation**
- Система продолжает работу даже с частичными данными
- Пользователь информируется о режиме данных

**Правило 4: Кеширование режима**
- При переключении на Mock из-за недоступности OData — кешировать это решение на 5 минут
- Не проверять OData при каждом запросе, если он недавно был недоступен

---

## 5.5 Декомпозиция файлов и модулей

### Domain Layer (backend/src/domain)

**Файл: entities/IRoute.ts**
- **Назначение:** Интерфейс доменной сущности "Маршрут"
- **Задачи:** Определение структуры маршрута (id, название, номер, тип транспорта, тариф)
- **Место в цепочке:** Используется во всех слоях как базовая структура маршрута

**Файл: entities/IStop.ts**
- **Назначение:** Интерфейс доменной сущности "Остановка"
- **Задачи:** Определение структуры остановки (id, название, координаты, адрес)
- **Место в цепочке:** Используется во всех слоях как базовая структура остановки

**Файл: entities/IFlight.ts**
- **Назначение:** Интерфейс доменной сущности "Рейс"
- **Задачи:** Определение структуры рейса (id, маршрут, время отправления, длительность)
- **Место в цепочке:** Используется для построения расписания в графе

**Файл: entities/TransportDataset.ts**
- **Назначение:** Доменная сущность унифицированного датасета
- **Задачи:** Объединение маршрутов, остановок, рейсов с метаданными о качестве и режиме
- **Место в цепочке:** Основной объект передачи данных между Application и Infrastructure слоями

**Файл: entities/QualityReport.ts**
- **Назначение:** Доменная сущность отчета о качестве данных
- **Задачи:** Содержание результатов валидации датасета
- **Место в цепочке:** Используется для принятия решений о восстановлении данных

**Файл: enums/DataSourceMode.ts**
- **Назначение:** Перечисление режимов источника данных
- **Задачи:** Определение возможных режимов (REAL, RECOVERY, MOCK)
- **Место в цепочке:** Используется для маркировки происхождения данных

**Файл: repositories/ITransportDataProvider.ts**
- **Назначение:** Интерфейс репозитория провайдера транспортных данных
- **Задачи:** Определение контракта для всех провайдеров (loadData, isAvailable)
- **Место в цепочке:** Реализуется в Infrastructure слое, используется в Application

---

### Application Layer (backend/src/application)

**Файл: use-cases/LoadTransportDataUseCase.ts**
- **Назначение:** Use-case загрузки транспортных данных
- **Задачи:** Координация процесса загрузки, обработка ошибок, логирование
- **Место в цепочке:** Вызывается из BuildRouteUseCase перед построением графа

**Файл: data-loading/TransportDataService.ts**
- **Назначение:** Центральный сервис управления данными
- **Задачи:** Выбор провайдера, валидация качества, применение восстановления, кеширование
- **Место в цепочке:** Вызывается из LoadTransportDataUseCase, координирует все провайдеры

**Файл: data-loading/DataRecoveryService.ts**
- **Назначение:** Сервис восстановления недостающих данных
- **Задачи:** Восстановление координат, генерация расписания, заполнение названий
- **Место в цепочке:** Вызывается из TransportDataService при режиме RECOVERY

**Файл: data-loading/QualityValidator.ts**
- **Назначение:** Валидатор качества транспортных данных
- **Задачи:** Проверка всех аспектов датасета, расчет показателя качества, формирование рекомендаций
- **Место в цепочке:** Вызывается из TransportDataService после загрузки данных

**Файл: route-builder/RouteGraphBuilder.ts (расширение)**
- **Назначение:** Построитель графа маршрутной сети
- **Задачи:** Новый метод buildFromDataset для построения графа из TransportDataset
- **Место в цепочке:** Вызывается из BuildRouteUseCase для построения графа

---

### Infrastructure Layer (backend/src/infrastructure)

**Файл: data-providers/ODataTransportProvider.ts**
- **Назначение:** Реализация ITransportDataProvider для OData
- **Задачи:** Загрузка данных из OData API, преобразование в TransportDataset
- **Место в цепочке:** Создается и используется в TransportDataService

**Файл: data-providers/MockTransportProvider.ts**
- **Назначение:** Реализация ITransportDataProvider для mock-данных
- **Задачи:** Загрузка данных из JSON-файлов, преобразование в TransportDataset
- **Место в цепочке:** Используется как fallback в TransportDataService

**Файл: cache/DatasetCacheRepository.ts**
- **Назначение:** Репозиторий кеширования датасетов в Redis
- **Задачи:** Сохранение и извлечение транспортных датасетов из кеша
- **Место в цепочке:** Используется в TransportDataService для оптимизации загрузки

**Файл: api/odata/RoutesService.ts (существующий)**
- **Назначение:** Сервис работы с маршрутами OData
- **Задачи:** Запросы к Catalog_Маршруты, преобразование данных
- **Место в цепочке:** Используется в ODataTransportProvider

**Файл: api/odata/StopsService.ts (существующий)**
- **Назначение:** Сервис работы с остановками OData
- **Задачи:** Запросы к Catalog_Остановки, преобразование данных
- **Место в цепочке:** Используется в ODataTransportProvider

**Файл: api/odata/FlightsService.ts (существующий)**
- **Назначение:** Сервис работы с расписанием OData
- **Задачи:** Запросы к Catalog_РейсыРасписания, преобразование данных
- **Место в цепочке:** Используется в ODataTransportProvider

**Файл: storage/MockDataLoader.ts (существующий)**
- **Назначение:** Загрузчик mock-данных из JSON
- **Задачи:** Чтение файлов routes.json, stops.json, flights.json
- **Место в цепочке:** Используется в MockTransportProvider

---

### Presentation Layer (backend/src/presentation)

**Файл: controllers/RouteBuilderController.ts (расширение)**
- **Назначение:** Контроллер построения маршрутов
- **Задачи:** Расширение ответа API полями dataMode и quality из TransportDataset
- **Место в цепочке:** Принимает запросы от frontend, вызывает BuildRouteUseCase

**Файл: controllers/DiagnosticsController.ts (новый)**
- **Назначение:** Контроллер диагностики системы загрузки данных
- **Задачи:** Предоставление информации о текущем режиме данных, качестве, времени последней загрузки
- **Место в цепочке:** Отдельный endpoint для мониторинга системы

---

## 5.6 Поток интеграции с BuildRouteUseCase

### Получение TransportDataset в BuildRouteUseCase

**Текущее состояние (до внедрения):**
BuildRouteUseCase напрямую вызывает RouteGraphBuilder.buildGraph, который внутри себя обращается к OData сервисам для загрузки данных.

**Новое состояние (после внедрения):**
BuildRouteUseCase сначала получает TransportDataset через LoadTransportDataUseCase, затем передает его в RouteGraphBuilder.buildFromDataset.

---

### Шаги интеграции

**Шаг 1: Внедрение зависимости**
- В конструктор BuildRouteUseCase добавляется LoadTransportDataUseCase
- Dependency Injection контейнер настраивается на создание LoadTransportDataUseCase

**Шаг 2: Вызов LoadTransportDataUseCase**
- В начале метода execute BuildRouteUseCase вызывается loadTransportDataUseCase.execute()
- Получен объект TransportDataset с полями: routes, stops, flights, mode, quality

**Шаг 3: Логирование режима данных**
- BuildRouteUseCase логирует режим данных (REAL/RECOVERY/MOCK)
- Логируется показатель качества
- При режиме MOCK выводится предупреждение

**Шаг 4: Передача датасета в RouteGraphBuilder**
- Вызывается новый метод routeGraphBuilder.buildFromDataset(transportDataset)
- Датасет передается целиком (вместо отдельных вызовов к OData сервисам)

**Шаг 5: Построение графа**
- RouteGraphBuilder строит граф из предоставленного датасета
- Граф содержит узлы (остановки) и рёбра (участки маршрутов)

**Шаг 6: Поиск маршрута**
- PathFinder выполняет поиск оптимального пути в графе
- Алгоритм поиска не меняется (работает с тем же графом)

**Шаг 7: Оценка рисков**
- RiskEngine оценивает найденные маршруты
- Риски рассчитываются независимо от режима данных

**Шаг 8: Формирование ответа**
- BuildRouteUseCase формирует IRouteBuilderResult
- Добавляются новые поля: dataMode и quality из TransportDataset
- Эти поля включаются в ответ API

---

### Изменения в RouteGraphBuilder

**Новый метод: buildFromDataset**

**Назначение:**
Построение графа из готового TransportDataset вместо прямой загрузки из OData.

**Отличия от существующего buildGraph:**

**buildGraph (старый):**
- Внутри метода вызываются OData сервисы
- Загрузка данных и построение графа смешаны
- Нет информации о качестве данных
- Всегда работает с OData

**buildFromDataset (новый):**
- Принимает готовый TransportDataset
- Фокусируется только на построении графа
- Работает с любым источником данных (OData, mock)
- Имеет доступ к метаданным (mode, quality)

**Внутренняя логика buildFromDataset:**

1. **Создание узлов из остановок:**
   - Для каждой остановки в dataset.stops создается узел графа
   - Узел содержит: id, название, координаты
   - Узлы индексируются по ID для быстрого поиска

2. **Создание рёбер из маршрутов:**
   - Для каждого маршрута в dataset.routes:
     - Извлекается последовательность остановок
     - Создаются рёбра между соседними остановками
     - Рёбра содержат: время в пути, стоимость, тип транспорта

3. **Интеграция расписания:**
   - Для каждого рейса в dataset.flights:
     - Ребра обогащаются информацией о времени отправления
     - Создаются временные слои графа (для Time-Dependent Shortest Path)

4. **Создание пересадочных узлов:**
   - Остановки с одинаковыми или близкими координатами объединяются
   - Создаются рёбра пересадки (transfer edges) с временем пересадки

5. **Валидация графа:**
   - Проверка связности графа
   - Проверка наличия изолированных узлов
   - Логирование статистики графа (количество узлов, рёбер)

6. **Возврат графа:**
   - Возвращается объект RouteGraph готовый для PathFinder

---

### Транспортировка dataMode и quality

**Путь данных через систему:**

1. **TransportDataset (Application Layer):**
   - mode: DataSourceMode (REAL/RECOVERY/MOCK)
   - quality: number (0-100)

2. **BuildRouteUseCase (Application Layer):**
   - Извлекает dataMode и quality из TransportDataset
   - Сохраняет в локальных переменных

3. **IRouteBuilderResult (Domain Entity):**
   - Расширяется двумя новыми полями:
     - dataMode: строковое представление режима
     - dataQuality: числовой показатель качества

4. **RouteBuilderController (Presentation Layer):**
   - Получает IRouteBuilderResult от BuildRouteUseCase
   - Преобразует в HTTP ответ
   - Включает dataMode и dataQuality в JSON

5. **Frontend (Client):**
   - Получает dataMode и dataQuality в ответе API
   - Отображает badge с режимом данных
   - Может показывать warning при режиме MOCK

**Пример структуры ответа API (после изменений):**

```
Ответ API содержит:
- routes: массив найденных маршрутов
- totalDistance: общее расстояние
- totalDuration: общее время
- totalCost: общая стоимость
- riskAssessment: оценка рисков
- dataMode: строка ("real" | "recovery" | "mock")
- dataQuality: число (0-100)
```

---

### Обратная совместимость

**Сохранение существующего buildGraph:**
- Метод buildGraph не удаляется
- Используется для legacy кода или прямых вызовов
- Внутренне может использовать buildFromDataset

**Поддержка обоих методов:**
- buildGraph — для обратной совместимости
- buildFromDataset — для новой архитектуры с адаптивной загрузкой

**Миграция:**
- Постепенная миграция всех use-cases на buildFromDataset
- Deprecated пометка для buildGraph
- Документирование нового подхода

---

## 5.7 Диаграмма последовательности (словесная)

### Сценарий: Полный цикл обработки запроса на построение маршрута

**Этап 1: Поступление запроса**
Клиент отправляет GET запрос на endpoint поиска маршрутов с параметрами: точка отправления, точка назначения, тип транспорта, время отправления.

**Этап 2: Обработка в контроллере**
RouteBuilderController получает запрос, валидирует параметры, извлекает значения из query string, создает объект параметров поиска.

**Этап 3: Вызов BuildRouteUseCase**
Контроллер вызывает метод execute у BuildRouteUseCase, передавая параметры поиска.

**Этап 4: Запрос транспортных данных**
BuildRouteUseCase вызывает LoadTransportDataUseCase для получения актуальных транспортных данных.

**Этап 5: Делегирование в TransportDataService**
LoadTransportDataUseCase делегирует загрузку в TransportDataService, вызывая метод loadData.

**Этап 6: Проверка кеша**
TransportDataService обращается к DatasetCacheRepository с запросом получения закешированного датасета по ключу "transport-dataset".

**Этап 7a: Cache Hit (кеш найден)**
Если DatasetCacheRepository возвращает датасет, TransportDataService пропускает загрузку и сразу возвращает закешированные данные.

**Этап 7b: Cache Miss (кеш пуст)**
Если кеш пуст, TransportDataService продолжает процесс загрузки данных.

**Этап 8: Выбор провайдера**
TransportDataService вызывает метод isAvailable у ODataTransportProvider для проверки доступности OData API.

**Этап 9a: OData доступен**
ODataTransportProvider пытается подключиться к OData API, выполняет тестовый запрос, получает успешный ответ, возвращает true.

**Этап 9b: OData недоступен**
ODataTransportProvider получает ошибку соединения (timeout, connection refused), возвращает false. TransportDataService переключается на MockTransportProvider.

**Этап 10: Загрузка данных через провайдера**
TransportDataService вызывает метод loadData у выбранного провайдера (OData или Mock).

**Этап 11a: Загрузка из OData**
ODataTransportProvider выполняет параллельные запросы к RoutesService, StopsService, FlightsService. Каждый сервис обращается к ODataClient для HTTP запросов. ODataClient отправляет GET запросы к OData API. OData API возвращает данные в формате JSON. Сервисы преобразуют OData-структуры в доменные сущности. ODataTransportProvider формирует TransportDataset и возвращает его.

**Этап 11b: Загрузка из Mock**
MockTransportProvider вызывает MockDataLoader для чтения JSON-файлов. MockDataLoader читает файлы routes.json, stops.json, flights.json из директории mock-данных. MockTransportProvider преобразует JSON в TransportDataset и возвращает его.

**Этап 12: Валидация качества**
TransportDataService передает полученный датасет в QualityValidator. QualityValidator выполняет проверки: наличие маршрутов, остановок, корректность координат, наличие расписания. QualityValidator рассчитывает показатели качества для каждой категории. QualityValidator вычисляет общий показатель качества (overallScore) как взвешенную сумму. QualityValidator формирует QualityReport с рекомендациями и возвращает его.

**Этап 13: Принятие решения о режиме**
TransportDataService анализирует показатель качества:
- Если качество >= 90 и источник OData — устанавливает режим REAL
- Если качество 50-89 и источник OData — устанавливает режим RECOVERY
- Если качество < 50 или источник Mock — устанавливает режим MOCK

**Этап 14a: Применение восстановления (режим RECOVERY)**
TransportDataService вызывает DataRecoveryService.recover, передавая датасет и QualityReport. DataRecoveryService анализирует отчет и определяет необходимые восстановления. DataRecoveryService восстанавливает координаты остановок: вызывает GeocodeService для геокодирования адресов, использует координаты соседних остановок, применяет центр города по умолчанию. DataRecoveryService генерирует расписание: извлекает шаблоны из ScheduleTemplateRepository, создает рейсы по типовым интервалам. DataRecoveryService заполняет недостающие названия остановок. DataRecoveryService возвращает восстановленный датасет. TransportDataService повторно вызывает QualityValidator для проверки качества после восстановления.

**Этап 14b: Fallback на Mock (если восстановление не помогло)**
Если после восстановления качество всё ещё < 50, TransportDataService вызывает MockTransportProvider.loadData. Получает mock-датасет с качеством 100. Устанавливает режим MOCK.

**Этап 14c: Использование без восстановления (режим REAL или MOCK)**
TransportDataService использует датасет как есть, без восстановления.

**Этап 15: Установка метаданных**
TransportDataService устанавливает в датасете: mode (REAL/RECOVERY/MOCK), quality (финальный показатель), loadedAt (текущая дата и время), source (имя провайдера).

**Этап 16: Кеширование**
TransportDataService вызывает DatasetCacheRepository.set для сохранения датасета в Redis с TTL 3600 секунд. DatasetCacheRepository сериализует датасет в JSON. RedisClient записывает данные в Redis с ключом "transport-dataset". Redis подтверждает запись.

**Этап 17: Возврат датасета**
TransportDataService возвращает готовый TransportDataset в LoadTransportDataUseCase. LoadTransportDataUseCase возвращает датасет в BuildRouteUseCase.

**Этап 18: Построение графа**
BuildRouteUseCase вызывает RouteGraphBuilder.buildFromDataset, передавая TransportDataset. RouteGraphBuilder создает узлы графа для каждой остановки из dataset.stops. RouteGraphBuilder создает рёбра графа для участков маршрутов из dataset.routes. RouteGraphBuilder интегрирует расписание из dataset.flights. RouteGraphBuilder создает пересадочные узлы для близких остановок. RouteGraphBuilder валидирует связность графа. RouteGraphBuilder возвращает объект RouteGraph.

**Этап 19: Поиск оптимального маршрута**
BuildRouteUseCase вызывает PathFinder для поиска пути от точки отправления до точки назначения. PathFinder применяет алгоритм поиска кратчайшего пути (Dijkstra/A*). PathFinder находит последовательность участков маршрутов. PathFinder возвращает массив найденных маршрутов.

**Этап 20: Оценка рисков**
BuildRouteUseCase вызывает RiskEngine для оценки рисков каждого найденного маршрута. RiskEngine анализирует факторы риска: время суток, погодные условия, загруженность транспорта. RiskEngine рассчитывает итоговую оценку риска для каждого маршрута. RiskEngine возвращает RiskAssessment.

**Этап 21: Формирование результата**
BuildRouteUseCase создает объект IRouteBuilderResult. Заполняет поля: routes (найденные маршруты), totalDistance, totalDuration, totalCost, riskAssessment, dataMode (из TransportDataset), dataQuality (из TransportDataset). Возвращает результат в RouteBuilderController.

**Этап 22: Формирование HTTP ответа**
RouteBuilderController преобразует IRouteBuilderResult в JSON. Устанавливает HTTP статус 200 OK. Добавляет заголовки (Content-Type: application/json). Отправляет ответ клиенту.

**Этап 23: Получение ответа клиентом**
Клиент получает JSON с маршрутами, метаданными о качестве данных и режиме. Frontend отображает найденные маршруты пользователю. Frontend показывает badge с режимом данных (REAL/RECOVERY/MOCK). При режиме MOCK может отобразить предупреждение о демонстрационных данных.

---

## 5.8 Краткое резюме для CTO

Low-Level Design документ для адаптивной системы загрузки транспортных данных (Вариант B) предоставляет детальное описание внутреннего устройства всех модулей на уровне логики и обязанностей, что критически важно для успешной реализации архитектуры. Документ раскрывает роли восьми ключевых модулей, их входы и выходы, зависимости и точки интеграции, обеспечивая разработчикам полное понимание того, как компоненты взаимодействуют друг с другом. Пошаговые псевдоалгоритмы работы модулей, описанные словами без кода, позволяют архитекторам и разработчикам проверить корректность бизнес-логики до начала имплементации, снижая риски ошибочных решений на ранних этапах. Алгоритм выбора режима источника данных с четкими критериями (качество >= 90 для REAL, 50-89 для RECOVERY, < 50 для MOCK) и fallback-правилами обеспечивает предсказуемое поведение системы в различных сценариях, включая недоступность внешнего API, что повышает надежность решения. Декомпозиция на 25+ файлов и модулей с точным описанием назначения каждого компонента упрощает планирование работы команды, распределение задач между разработчиками и параллельную разработку. Детальное описание интеграции с существующим BuildRouteUseCase и расширения RouteGraphBuilder новым методом buildFromDataset гарантирует обратную совместимость с текущей кодовой базой и плавную миграцию без breaking changes. Словесная диаграмма последовательности из 23 этапов, охватывающая весь путь от HTTP запроса до ответа клиенту с учетом кеширования, валидации качества и восстановления данных, служит эталоном для разработки и тестирования, обеспечивая единое понимание потока данных всеми участниками проекта.

---

**Документ готов к использованию разработчиками для имплементации Варианта B.**

**Следующий этап:** Переход к кодированию модулей согласно описанной архитектуре.

