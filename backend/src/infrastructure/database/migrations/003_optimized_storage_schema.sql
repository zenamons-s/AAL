-- Migration 003: Optimized Storage Schema
-- Purpose: Create tables for permanent storage of stops, routes, flights, virtual entities, and metadata
-- This migration implements the three-tier storage architecture (PostgreSQL + Redis + MinIO)

-- ============================================================================
-- SECTION 1: Real Entities (from OData)
-- ============================================================================

/**
 * Table: stops
 * Stores real stops from OData API
 * Never recreated on startup - only updated by Worker 1
 */
CREATE TABLE IF NOT EXISTS stops (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  city_id VARCHAR(50),
  is_airport BOOLEAN DEFAULT FALSE,
  is_railway_station BOOLEAN DEFAULT FALSE,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for stops
CREATE INDEX IF NOT EXISTS idx_stops_city ON stops(city_id);
CREATE INDEX IF NOT EXISTS idx_stops_coords ON stops USING GIST (
  point(longitude, latitude)
);
CREATE INDEX IF NOT EXISTS idx_stops_airport ON stops(is_airport) WHERE is_airport = TRUE;
CREATE INDEX IF NOT EXISTS idx_stops_railway ON stops(is_railway_station) WHERE is_railway_station = TRUE;
CREATE INDEX IF NOT EXISTS idx_stops_name ON stops USING gin(to_tsvector('russian', name));

COMMENT ON TABLE stops IS 'Real stops from OData API - permanent storage';
COMMENT ON COLUMN stops.metadata IS 'Additional data: address, timezone, facilities, etc.';

-- ============================================================================
-- SECTION 2: Virtual Entities (generated by Worker 2)
-- ============================================================================

/**
 * Table: virtual_stops
 * Stores virtual grid stops for comprehensive route coverage
 * Created once by Worker 2 - never recreated on requests
 */
CREATE TABLE IF NOT EXISTS virtual_stops (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  city_id VARCHAR(50),
  grid_type VARCHAR(20) NOT NULL CHECK (grid_type IN ('MAIN_GRID', 'DENSE_CITY', 'AIRPORT_GRID')),
  grid_position JSONB, -- {x: number, y: number}
  real_stops_nearby JSONB[], -- [{stopId, distance}]
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for virtual_stops
CREATE INDEX IF NOT EXISTS idx_virtual_stops_city ON virtual_stops(city_id);
CREATE INDEX IF NOT EXISTS idx_virtual_stops_type ON virtual_stops(grid_type);
CREATE INDEX IF NOT EXISTS idx_virtual_stops_coords ON virtual_stops USING GIST (
  point(longitude, latitude)
);

COMMENT ON TABLE virtual_stops IS 'Virtual grid stops - created once by Worker 2';
COMMENT ON COLUMN virtual_stops.grid_type IS 'Type of virtual stop: MAIN_GRID (50km), DENSE_CITY (10km), AIRPORT_GRID (5km)';
COMMENT ON COLUMN virtual_stops.real_stops_nearby IS 'Array of nearby real stops with distances for connectivity';

-- ============================================================================
-- SECTION 3: Routes
-- ============================================================================

/**
 * Table: routes
 * Stores real routes from OData API
 * Updated by Worker 1 when OData changes
 */
CREATE TABLE IF NOT EXISTS routes (
  id VARCHAR(50) PRIMARY KEY,
  route_number VARCHAR(50),
  transport_type VARCHAR(20) NOT NULL CHECK (transport_type IN ('BUS', 'TRAIN', 'PLANE', 'WATER')),
  from_stop_id VARCHAR(50) NOT NULL,
  to_stop_id VARCHAR(50) NOT NULL,
  stops_sequence JSONB NOT NULL, -- [{stopId, order, arrivalTime, departureTime}]
  duration_minutes INTEGER,
  distance_km DECIMAL(10, 2),
  operator VARCHAR(255),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  CONSTRAINT fk_routes_from_stop FOREIGN KEY (from_stop_id) REFERENCES stops(id) ON DELETE CASCADE,
  CONSTRAINT fk_routes_to_stop FOREIGN KEY (to_stop_id) REFERENCES stops(id) ON DELETE CASCADE
);

-- Indexes for routes
CREATE INDEX IF NOT EXISTS idx_routes_from_stop ON routes(from_stop_id);
CREATE INDEX IF NOT EXISTS idx_routes_to_stop ON routes(to_stop_id);
CREATE INDEX IF NOT EXISTS idx_routes_transport ON routes(transport_type);
CREATE INDEX IF NOT EXISTS idx_routes_route_number ON routes(route_number);

COMMENT ON TABLE routes IS 'Real routes from OData API';
COMMENT ON COLUMN routes.stops_sequence IS 'Ordered list of stops with arrival/departure times';

/**
 * Table: virtual_routes
 * Stores virtual connections between stops (real-to-virtual, virtual-to-real, virtual-to-virtual)
 * Created once by Worker 2 - never recreated on requests
 */
CREATE TABLE IF NOT EXISTS virtual_routes (
  id VARCHAR(50) PRIMARY KEY,
  route_type VARCHAR(30) NOT NULL CHECK (route_type IN ('REAL_TO_VIRTUAL', 'VIRTUAL_TO_REAL', 'VIRTUAL_TO_VIRTUAL')),
  from_stop_id VARCHAR(50) NOT NULL,
  to_stop_id VARCHAR(50) NOT NULL,
  distance_km DECIMAL(10, 2),
  duration_minutes INTEGER,
  transport_mode VARCHAR(20) DEFAULT 'WALK' CHECK (transport_mode IN ('WALK', 'TRANSFER', 'SHUTTLE')),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for virtual_routes
CREATE INDEX IF NOT EXISTS idx_virtual_routes_from ON virtual_routes(from_stop_id);
CREATE INDEX IF NOT EXISTS idx_virtual_routes_to ON virtual_routes(to_stop_id);
CREATE INDEX IF NOT EXISTS idx_virtual_routes_type ON virtual_routes(route_type);

COMMENT ON TABLE virtual_routes IS 'Virtual connections - created once by Worker 2';
COMMENT ON COLUMN virtual_routes.transport_mode IS 'How to travel this virtual connection: WALK, TRANSFER, SHUTTLE';

-- ============================================================================
-- SECTION 4: Flights (Schedule)
-- ============================================================================

/**
 * Table: flights
 * Stores all flights (real + virtual) with schedule information
 * Real flights from OData (Worker 1), virtual flights generated by Worker 2
 */
CREATE TABLE IF NOT EXISTS flights (
  id VARCHAR(50) PRIMARY KEY,
  route_id VARCHAR(50), -- NULL for virtual flights
  from_stop_id VARCHAR(50) NOT NULL,
  to_stop_id VARCHAR(50) NOT NULL,
  departure_time TIME NOT NULL,
  arrival_time TIME NOT NULL,
  days_of_week INTEGER[] NOT NULL, -- [1,2,3,4,5,6,7] (Monday-Sunday)
  price_rub DECIMAL(10, 2),
  is_virtual BOOLEAN DEFAULT FALSE,
  transport_type VARCHAR(20),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for flights
CREATE INDEX IF NOT EXISTS idx_flights_route ON flights(route_id);
CREATE INDEX IF NOT EXISTS idx_flights_from_stop ON flights(from_stop_id);
CREATE INDEX IF NOT EXISTS idx_flights_to_stop ON flights(to_stop_id);
CREATE INDEX IF NOT EXISTS idx_flights_departure ON flights(departure_time);
CREATE INDEX IF NOT EXISTS idx_flights_is_virtual ON flights(is_virtual);
CREATE INDEX IF NOT EXISTS idx_flights_days ON flights USING GIN(days_of_week);

COMMENT ON TABLE flights IS 'All flights (real + virtual) with schedule';
COMMENT ON COLUMN flights.days_of_week IS 'Days when this flight operates: 1=Monday, 7=Sunday';
COMMENT ON COLUMN flights.is_virtual IS 'TRUE if this is a generated virtual flight';

-- ============================================================================
-- SECTION 5: Metadata Tables
-- ============================================================================

/**
 * Table: datasets
 * Stores metadata about dataset versions
 * Tracks changes via OData hash
 */
CREATE TABLE IF NOT EXISTS datasets (
  id SERIAL PRIMARY KEY,
  version VARCHAR(50) UNIQUE NOT NULL,
  source_type VARCHAR(20) NOT NULL CHECK (source_type IN ('ODATA', 'MOCK', 'HYBRID')),
  quality_score INTEGER CHECK (quality_score >= 0 AND quality_score <= 100),
  total_stops INTEGER DEFAULT 0,
  total_routes INTEGER DEFAULT 0,
  total_flights INTEGER DEFAULT 0,
  total_virtual_stops INTEGER DEFAULT 0,
  total_virtual_routes INTEGER DEFAULT 0,
  odata_hash VARCHAR(64), -- SHA256 hash of OData response
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT FALSE
);

-- Indexes for datasets
CREATE INDEX IF NOT EXISTS idx_datasets_version ON datasets(version);
CREATE UNIQUE INDEX IF NOT EXISTS idx_datasets_active ON datasets(is_active) WHERE is_active = TRUE;

COMMENT ON TABLE datasets IS 'Metadata about dataset versions';
COMMENT ON COLUMN datasets.odata_hash IS 'SHA256 hash of OData response - used to detect changes';
COMMENT ON COLUMN datasets.is_active IS 'Only one dataset version can be active at a time';

/**
 * Table: graphs
 * Stores metadata about built graphs
 * Links to Redis keys and MinIO backups
 */
CREATE TABLE IF NOT EXISTS graphs (
  id SERIAL PRIMARY KEY,
  version VARCHAR(50) UNIQUE NOT NULL,
  dataset_version VARCHAR(50) NOT NULL,
  total_nodes INTEGER DEFAULT 0,
  total_edges INTEGER DEFAULT 0,
  build_duration_ms INTEGER,
  redis_key VARCHAR(100), -- 'graph:v1.2.3'
  minio_backup_path VARCHAR(255), -- 'graph/export-v1.2.3.json'
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT FALSE,
  CONSTRAINT fk_graphs_dataset FOREIGN KEY (dataset_version) REFERENCES datasets(version) ON DELETE CASCADE
);

-- Indexes for graphs
CREATE INDEX IF NOT EXISTS idx_graphs_version ON graphs(version);
CREATE INDEX IF NOT EXISTS idx_graphs_dataset ON graphs(dataset_version);
CREATE UNIQUE INDEX IF NOT EXISTS idx_graphs_active ON graphs(is_active) WHERE is_active = TRUE;

COMMENT ON TABLE graphs IS 'Metadata about built graphs';
COMMENT ON COLUMN graphs.redis_key IS 'Redis key where this graph is stored';
COMMENT ON COLUMN graphs.minio_backup_path IS 'Path to graph backup in MinIO';
COMMENT ON COLUMN graphs.is_active IS 'Only one graph version can be active at a time';

-- ============================================================================
-- SECTION 6: Functions and Triggers
-- ============================================================================

/**
 * Function: update_updated_at
 * Automatically updates the updated_at timestamp
 */
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to stops (drop if exists to avoid conflicts)
DROP TRIGGER IF EXISTS trigger_stops_updated_at ON stops;
CREATE TRIGGER trigger_stops_updated_at
BEFORE UPDATE ON stops
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

-- Apply trigger to routes (drop if exists to avoid conflicts)
DROP TRIGGER IF EXISTS trigger_routes_updated_at ON routes;
CREATE TRIGGER trigger_routes_updated_at
BEFORE UPDATE ON routes
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

/**
 * Function: ensure_single_active_dataset
 * Ensures only one dataset is marked as active
 */
CREATE OR REPLACE FUNCTION ensure_single_active_dataset()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_active = TRUE THEN
    UPDATE datasets SET is_active = FALSE WHERE id != NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if exists to avoid conflicts
DROP TRIGGER IF EXISTS trigger_single_active_dataset ON datasets;
CREATE TRIGGER trigger_single_active_dataset
BEFORE INSERT OR UPDATE ON datasets
FOR EACH ROW
EXECUTE FUNCTION ensure_single_active_dataset();

/**
 * Function: ensure_single_active_graph
 * Ensures only one graph is marked as active
 */
CREATE OR REPLACE FUNCTION ensure_single_active_graph()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_active = TRUE THEN
    UPDATE graphs SET is_active = FALSE WHERE id != NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if exists to avoid conflicts
DROP TRIGGER IF EXISTS trigger_single_active_graph ON graphs;
CREATE TRIGGER trigger_single_active_graph
BEFORE INSERT OR UPDATE ON graphs
FOR EACH ROW
EXECUTE FUNCTION ensure_single_active_graph();

-- ============================================================================
-- SECTION 7: Initial Data
-- ============================================================================

-- Insert initial dataset version (empty)
INSERT INTO datasets (
  version,
  source_type,
  quality_score,
  metadata,
  is_active
) VALUES (
  'initial-v1.0.0',
  'MOCK',
  0,
  '{"description": "Initial empty dataset"}',
  FALSE
) ON CONFLICT (version) DO NOTHING;

-- ============================================================================
-- SECTION 8: Cleanup Functions
-- ============================================================================

/**
 * Function: cleanup_old_datasets
 * Removes datasets older than specified days (keeps last N versions)
 */
CREATE OR REPLACE FUNCTION cleanup_old_datasets(keep_count INTEGER DEFAULT 10)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  WITH old_datasets AS (
    SELECT id
    FROM datasets
    WHERE is_active = FALSE
    ORDER BY created_at DESC
    OFFSET keep_count
  )
  DELETE FROM datasets
  WHERE id IN (SELECT id FROM old_datasets);
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

/**
 * Function: cleanup_old_graphs
 * Removes graphs older than specified days (keeps last N versions)
 */
CREATE OR REPLACE FUNCTION cleanup_old_graphs(keep_count INTEGER DEFAULT 10)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  WITH old_graphs AS (
    SELECT id
    FROM graphs
    WHERE is_active = FALSE
    ORDER BY created_at DESC
    OFFSET keep_count
  )
  DELETE FROM graphs
  WHERE id IN (SELECT id FROM old_graphs);
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SECTION 9: Views for Monitoring
-- ============================================================================

/**
 * View: current_dataset_stats
 * Shows statistics for the currently active dataset
 */
CREATE OR REPLACE VIEW current_dataset_stats AS
SELECT
  version,
  source_type,
  quality_score,
  total_stops,
  total_routes,
  total_flights,
  total_virtual_stops,
  total_virtual_routes,
  created_at
FROM datasets
WHERE is_active = TRUE;

/**
 * View: current_graph_stats
 * Shows statistics for the currently active graph
 */
CREATE OR REPLACE VIEW current_graph_stats AS
SELECT
  g.version,
  g.dataset_version,
  g.total_nodes,
  g.total_edges,
  g.build_duration_ms,
  g.redis_key,
  g.minio_backup_path,
  g.created_at
FROM graphs g
WHERE g.is_active = TRUE;

/**
 * View: system_health
 * Overall system health check
 */
CREATE OR REPLACE VIEW system_health AS
SELECT
  (SELECT COUNT(*) FROM stops) as real_stops_count,
  (SELECT COUNT(*) FROM virtual_stops) as virtual_stops_count,
  (SELECT COUNT(*) FROM routes) as real_routes_count,
  (SELECT COUNT(*) FROM virtual_routes) as virtual_routes_count,
  (SELECT COUNT(*) FROM flights WHERE is_virtual = FALSE) as real_flights_count,
  (SELECT COUNT(*) FROM flights WHERE is_virtual = TRUE) as virtual_flights_count,
  (SELECT version FROM datasets WHERE is_active = TRUE) as active_dataset_version,
  (SELECT version FROM graphs WHERE is_active = TRUE) as active_graph_version;

-- ============================================================================
-- Migration Complete
-- ============================================================================

COMMENT ON SCHEMA public IS 'Optimized storage schema - Migration 003';

