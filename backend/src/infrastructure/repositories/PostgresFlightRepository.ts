import type { Pool } from 'pg';
import type { IFlightRepository } from '../../domain/repositories/IFlightRepository';
import { Flight } from '../../domain/entities';
import type { TransportType } from '../../domain/entities';

/**
 * PostgreSQL implementation of IFlightRepository
 * 
 * Handles persistent storage of flights (real and virtual).
 * Real flights updated by Worker 1, virtual flights generated by Worker 2.
 * 
 * @implements {IFlightRepository}
 */
export class PostgresFlightRepository implements IFlightRepository {
  constructor(private readonly pool: Pool) {}

  // ============================================================================
  // Basic CRUD Operations
  // ============================================================================

  async findById(id: string): Promise<Flight | undefined> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE id = $1',
      [id]
    );

    if (result.rows.length === 0) return undefined;

    return this.mapRowToFlight(result.rows[0]);
  }

  async getAllFlights(includeVirtual: boolean = true): Promise<Flight[]> {
    const query = includeVirtual
      ? 'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights ORDER BY departure_time'
      : 'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE is_virtual = FALSE ORDER BY departure_time';

    const result = await this.pool.query(query);
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  async getVirtualFlights(): Promise<Flight[]> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE is_virtual = TRUE ORDER BY departure_time'
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  async getRealFlights(): Promise<Flight[]> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE is_virtual = FALSE ORDER BY departure_time'
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  // ============================================================================
  // Query Operations
  // ============================================================================

  async getFlightsByRoute(routeId: string): Promise<Flight[]> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE route_id = $1 ORDER BY departure_time',
      [routeId]
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  async getFlightsFromStop(stopId: string, date?: Date): Promise<Flight[]> {
    if (date) {
      const dayOfWeek = this.getDayOfWeek(date);
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE from_stop_id = $1 AND $2 = ANY(days_of_week) ORDER BY departure_time',
        [stopId, dayOfWeek]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    } else {
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE from_stop_id = $1 ORDER BY departure_time',
        [stopId]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    }
  }

  async getFlightsToStop(stopId: string, date?: Date): Promise<Flight[]> {
    if (date) {
      const dayOfWeek = this.getDayOfWeek(date);
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE to_stop_id = $1 AND $2 = ANY(days_of_week) ORDER BY arrival_time',
        [stopId, dayOfWeek]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    } else {
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE to_stop_id = $1 ORDER BY arrival_time',
        [stopId]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    }
  }

  async getFlightsBetweenStops(
    fromStopId: string,
    toStopId: string,
    date?: Date
  ): Promise<Flight[]> {
    if (date) {
      const dayOfWeek = this.getDayOfWeek(date);
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE from_stop_id = $1 AND to_stop_id = $2 AND $3 = ANY(days_of_week) ORDER BY departure_time',
        [fromStopId, toStopId, dayOfWeek]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    } else {
      const result = await this.pool.query(
        'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE from_stop_id = $1 AND to_stop_id = $2 ORDER BY departure_time',
        [fromStopId, toStopId]
      );
      return result.rows.map(row => this.mapRowToFlight(row));
    }
  }

  async getFlightsByTransportType(transportType: string): Promise<Flight[]> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE transport_type = $1 ORDER BY departure_time',
      [transportType]
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  async getFlightsByDayOfWeek(dayOfWeek: number): Promise<Flight[]> {
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE $1 = ANY(days_of_week) ORDER BY departure_time',
      [dayOfWeek]
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  async getFlightsByDate(date: Date): Promise<Flight[]> {
    const dayOfWeek = this.getDayOfWeek(date);
    const result = await this.pool.query(
      'SELECT id, route_id, from_stop_id, to_stop_id, departure_time, arrival_time, days_of_week, price_rub, is_virtual, transport_type, metadata, created_at FROM flights WHERE $1 = ANY(days_of_week) ORDER BY departure_time',
      [dayOfWeek]
    );
    return result.rows.map(row => this.mapRowToFlight(row));
  }

  // ============================================================================
  // Save Operations
  // ============================================================================

  async saveFlight(flight: Flight): Promise<Flight> {
    const query = `
      INSERT INTO flights (
        id, route_id, from_stop_id, to_stop_id,
        departure_time, arrival_time, days_of_week,
        price_rub, is_virtual, transport_type,
        metadata, created_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      ON CONFLICT (id)
      DO UPDATE SET
        route_id = EXCLUDED.route_id,
        from_stop_id = EXCLUDED.from_stop_id,
        to_stop_id = EXCLUDED.to_stop_id,
        departure_time = EXCLUDED.departure_time,
        arrival_time = EXCLUDED.arrival_time,
        days_of_week = EXCLUDED.days_of_week,
        price_rub = EXCLUDED.price_rub,
        is_virtual = EXCLUDED.is_virtual,
        transport_type = EXCLUDED.transport_type,
        metadata = EXCLUDED.metadata
      RETURNING *
    `;

    const result = await this.pool.query(query, [
      flight.id,
      flight.routeId,
      flight.fromStopId,
      flight.toStopId,
      flight.departureTime,
      flight.arrivalTime,
      flight.daysOfWeek,
      flight.priceRub,
      flight.isVirtual,
      flight.transportType,
      JSON.stringify(flight.metadata || null),
      flight.createdAt || new Date()
    ]);

    return this.mapRowToFlight(result.rows[0]);
  }

  async saveFlightsBatch(flights: Flight[]): Promise<Flight[]> {
    if (flights.length === 0) return [];

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      const savedFlights: Flight[] = [];
      for (const flight of flights) {
        const query = `
          INSERT INTO flights (
            id, route_id, from_stop_id, to_stop_id,
            departure_time, arrival_time, days_of_week,
            price_rub, is_virtual, transport_type,
            metadata, created_at
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          ON CONFLICT (id)
          DO UPDATE SET
            route_id = EXCLUDED.route_id,
            from_stop_id = EXCLUDED.from_stop_id,
            to_stop_id = EXCLUDED.to_stop_id,
            departure_time = EXCLUDED.departure_time,
            arrival_time = EXCLUDED.arrival_time,
            days_of_week = EXCLUDED.days_of_week,
            price_rub = EXCLUDED.price_rub,
            is_virtual = EXCLUDED.is_virtual,
            transport_type = EXCLUDED.transport_type,
            metadata = EXCLUDED.metadata
          RETURNING *
        `;

        const result = await client.query(query, [
          flight.id,
          flight.routeId,
          flight.fromStopId,
          flight.toStopId,
          flight.departureTime,
          flight.arrivalTime,
          flight.daysOfWeek,
          flight.priceRub,
          flight.isVirtual,
          flight.transportType,
          JSON.stringify(flight.metadata || null),
          flight.createdAt || new Date()
        ]);

        savedFlights.push(this.mapRowToFlight(result.rows[0]));
      }

      await client.query('COMMIT');
      return savedFlights;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // ============================================================================
  // Delete Operations
  // ============================================================================

  async deleteFlight(id: string): Promise<boolean> {
    const result = await this.pool.query('DELETE FROM flights WHERE id = $1', [id]);
    return result.rowCount !== null && result.rowCount > 0;
  }

  async deleteAllVirtualFlights(): Promise<number> {
    const result = await this.pool.query('DELETE FROM flights WHERE is_virtual = TRUE');
    return result.rowCount || 0;
  }

  async deleteFlightsByRoute(routeId: string): Promise<number> {
    const result = await this.pool.query('DELETE FROM flights WHERE route_id = $1', [routeId]);
    return result.rowCount || 0;
  }

  // ============================================================================
  // Count Operations
  // ============================================================================

  async countFlights(includeVirtual: boolean = true): Promise<number> {
    const query = includeVirtual
      ? 'SELECT COUNT(*) as count FROM flights'
      : 'SELECT COUNT(*) as count FROM flights WHERE is_virtual = FALSE';

    const result = await this.pool.query(query);
    return parseInt(result.rows[0].count, 10);
  }

  async countVirtualFlights(): Promise<number> {
    const result = await this.pool.query('SELECT COUNT(*) as count FROM flights WHERE is_virtual = TRUE');
    return parseInt(result.rows[0].count, 10);
  }

  async countRealFlights(): Promise<number> {
    const result = await this.pool.query('SELECT COUNT(*) as count FROM flights WHERE is_virtual = FALSE');
    return parseInt(result.rows[0].count, 10);
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Gets day of week from date (1-7, Monday-Sunday)
   */
  private getDayOfWeek(date: Date): number {
    const day = date.getDay();
    return day === 0 ? 7 : day; // Sunday is 7, not 0
  }

  /**
   * Maps database row to Flight entity
   */
  private mapRowToFlight(row: Record<string, unknown>): Flight {
    // Parse days_of_week array - ensure it's not empty
    let daysOfWeek: number[] = [];
    if (row.days_of_week) {
      daysOfWeek = Array.isArray(row.days_of_week) 
        ? row.days_of_week 
        : JSON.parse(row.days_of_week as string);
    }
    
    // Default to all days if empty
    if (!daysOfWeek || daysOfWeek.length === 0) {
      daysOfWeek = [1, 2, 3, 4, 5, 6, 7];
    }

    // Convert TIME to HH:MM string format
    const departureTime = this.convertTimeToString(row.departure_time);
    const arrivalTime = this.convertTimeToString(row.arrival_time);

    // Parse metadata from JSONB
    let metadata: Record<string, unknown> | undefined = undefined;
    if (row.metadata) {
      metadata = typeof row.metadata === 'string'
        ? JSON.parse(row.metadata)
        : row.metadata as Record<string, unknown>;
    }

    return new Flight(
      row.id as string,
      row.from_stop_id as string,
      row.to_stop_id as string,
      departureTime,
      arrivalTime,
      daysOfWeek,
      row.route_id as string | undefined,
      row.price_rub ? parseFloat(row.price_rub as string) : undefined,
      row.is_virtual as boolean,
      row.transport_type as TransportType | undefined,
      metadata,
      row.created_at as Date
    );
  }

  /**
   * Converts TIME value from database to HH:MM string format
   */
  private convertTimeToString(time: unknown): string {
    if (!time) {
      throw new Error('Time is required');
    }

    // If already a string in HH:MM format, return as is
    if (typeof time === 'string' && /^([0-1][0-9]|2[0-3]):([0-5][0-9])$/.test(time)) {
      return time;
    }

    // If it's a Date object, extract HH:MM
    if (time instanceof Date) {
      const hours = String(time.getUTCHours()).padStart(2, '0');
      const minutes = String(time.getUTCMinutes()).padStart(2, '0');
      return `${hours}:${minutes}`;
    }

    // If it's a string, try to parse it
    if (typeof time === 'string') {
      // Try ISO format
      if (time.includes('T')) {
        const date = new Date(time);
        if (!isNaN(date.getTime())) {
          const hours = String(date.getUTCHours()).padStart(2, '0');
          const minutes = String(date.getUTCMinutes()).padStart(2, '0');
          return `${hours}:${minutes}`;
        }
      }

      // Try to extract HH:MM from string
      const match = time.match(/([0-1][0-9]|2[0-3]):([0-5][0-9])/);
      if (match) {
        return match[0];
      }
    }

    // PostgreSQL TIME type returns as string in format "HH:MM:SS" or "HH:MM:SS.mmm"
    if (typeof time === 'string') {
      const parts = time.split(':');
      if (parts.length >= 2) {
        const hours = parts[0].padStart(2, '0');
        const minutes = parts[1].padStart(2, '0');
        return `${hours}:${minutes}`;
      }
    }

    throw new Error(`Cannot convert time to HH:MM format: ${String(time)}`);
  }
}

