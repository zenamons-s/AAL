# Полный аудит входных параметров маршрутов

## Резюме

**Проблема:** Frontend не отправляет запрос `/routes/search`, хотя backend работает корректно.

**Причина:** Параметр `date` передается как пустая строка `''` из URL в `useRoutesSearch`, что приводит к включению пустой строки в `queryKey` React Query. При этом `enabled` проверяет только `from` и `to`, но не валидирует формат `date`. Если `date` присутствует в URL как пустая строка, это может вызвать проблемы с кешированием React Query или блокировку запроса.

**Место блокировки:** `frontend/src/modules/routes/hooks/use-routes-search.ts`, строка 97 (queryKey) и строка 142 (enabled).

---

## Шаг 1. Проверка параметров из page.tsx

### Файл: `frontend/src/app/routes/page.tsx`

**Строки 27-30:**
```typescript
const from = searchParams.get('from') || ''
const to = searchParams.get('to') || ''
const date = searchParams.get('date') || ''
const passengers = searchParams.get('passengers') || '1'
```

### Анализ:

1. **`from`**: Может быть пустой строкой `''`, если параметр отсутствует в URL
2. **`to`**: Может быть пустой строкой `''`, если параметр отсутствует в URL
3. **`date`**: Может быть пустой строкой `''`, если параметр отсутствует в URL
4. **`passengers`**: По умолчанию `'1'`, но может быть любым значением из URL

### Проблемы:

- **Пустая строка `date`**: Если в URL есть параметр `date` без значения (например, `?from=Якутск&to=Мирный&date=`), то `searchParams.get('date')` вернет пустую строку `''`, а не `null`
- **Нет валидации формата**: Параметры передаются в `useRoutesSearch` без предварительной валидации формата
- **Нет проверки на пустые значения**: Пустые строки передаются как есть

### Строка 32:
```typescript
const { routes, alternatives, dataMode, dataQuality, isLoading, error, errorCode } = useRoutesSearch({
```

**Проблема:** Используются `dataMode` и `dataQuality`, которые были удалены из `UseRoutesSearchResult` в предыдущих исправлениях. Это вызовет ошибку TypeScript, но не должно блокировать запрос (если TypeScript не настроен на строгую проверку).

---

## Шаг 2. Проверка Zod-схемы входных параметров

### Файл: `frontend/src/modules/routes/schemas/route.schema.ts`

**Строки 33-48:**
```typescript
date: z
  .string()
  .regex(/^\d{4}-\d{2}-\d{2}$/, 'Неверный формат даты. Используйте формат YYYY-MM-DD')
  .optional()
  .refine(
    (val) => {
      if (!val) return true
      const date = new Date(val)
      const today = new Date()
      today.setHours(0, 0, 0, 0)
      return date >= today
    },
    {
      message: 'Дата не может быть в прошлом',
    }
  ),
```

### Анализ:

1. **Формат даты**: Требуется строго `YYYY-MM-DD` (например, `2025-01-15`)
2. **Опциональность**: Поле опционально (`.optional()`)
3. **Проверка на пустую строку**: `.regex()` применяется ДО `.optional()`, что означает, что пустая строка `''` НЕ пройдет валидацию regex

### Проблема:

**Критическая проблема:** Если `date` передается как пустая строка `''`, то:
- `.regex(/^\d{4}-\d{2}-\d{2}$/)` вернет `false` для пустой строки
- Zod выбросит ошибку валидации: "Неверный формат даты. Используйте формат YYYY-MM-DD"
- Но эта валидация происходит только в `search-form.tsx` при отправке формы, НЕ в `page.tsx` при чтении из URL

### Вывод:

Zod-схема не применяется к параметрам, прочитанным из URL в `page.tsx`. Параметры передаются в `useRoutesSearch` без валидации.

---

## Шаг 3. Проверка формирования queryKey в useQuery

### Файл: `frontend/src/modules/routes/hooks/use-routes-search.ts`

**Строка 97:**
```typescript
queryKey: ['routes', 'search', normalizedFrom, normalizedTo, date, passengers],
```

### Анализ:

1. **`normalizedFrom`**: `from.trim()` - может быть пустой строкой `''`
2. **`normalizedTo`**: `to.trim()` - может быть пустой строкой `''`
3. **`date`**: Передается как есть, без нормализации - может быть пустой строкой `''`
4. **`passengers`**: Передается как есть - по умолчанию `'1'`

### Проблемы:

1. **Пустая строка в queryKey**: Если `date` = `''`, то `queryKey` будет: `['routes', 'search', 'Якутск', 'Мирный', '', '1']`
   - React Query использует `queryKey` для кеширования
   - Пустая строка в `queryKey` может вызвать проблемы с кешированием
   - Если `date` меняется с `''` на реальную дату, React Query создаст новый кеш-ключ

2. **Нет нормализации `date`**: В отличие от `from` и `to`, `date` не нормализуется (не применяется `.trim()`)

3. **Нет проверки формата**: `date` может быть в любом формате (например, `'invalid-date'`), и это попадет в `queryKey`

### Вывод:

Пустая строка `date` в `queryKey` может вызвать проблемы с кешированием React Query, но не должна блокировать выполнение `queryFn`.

---

## Шаг 4. Проверка ранних проверок в useRoutesSearch

### Файл: `frontend/src/modules/routes/hooks/use-routes-search.ts`

**Строка 142:**
```typescript
enabled: Boolean(normalizedFrom && normalizedTo),
```

### Анализ:

1. **Проверка `enabled`**: Проверяет только `normalizedFrom` и `normalizedTo`
2. **Не проверяет `date`**: `date` не участвует в проверке `enabled`
3. **Не проверяет формат**: Не валидирует формат `date` перед включением запроса

### Проблема:

**Критическая проблема:** Если `date` передается как пустая строка `''` или в неверном формате:
- `enabled` все равно будет `true` (если `from` и `to` заполнены)
- `queryFn` будет вызван
- Но в `queryFn` (строка 104) есть проверка `if (date)`, которая пропустит пустую строку
- Однако пустая строка уже попала в `queryKey`, что может вызвать проблемы

### Строки 93-94:
```typescript
const normalizedFrom = from.trim()
const normalizedTo = to.trim()
```

**Проблема:** `date` не нормализуется. Если `date` = `'  '` (пробелы), то она передается как есть.

### Вывод:

Нет ранних проверок, которые блокируют выполнение `queryFn` из-за `date`. `enabled` проверяет только `from` и `to`.

---

## Шаг 5. Проверка вызова queryFn

### Файл: `frontend/src/modules/routes/hooks/use-routes-search.ts`

**Строки 98-141:**
```typescript
queryFn: async () => {
  const params = new URLSearchParams({
    from: normalizedFrom,
    to: normalizedTo,
  })

  if (date) {
    params.set('date', date)
  }

  if (passengers && passengers !== '1') {
    params.set('passengers', passengers)
  }

  try {
    const response = await fetchApi<unknown>(`/routes/search?${params.toString()}`)
    // ...
  }
}
```

### Анализ:

1. **Условие `if (date)`**: Пустая строка `''` - это falsy, поэтому `date` не добавится в `params`
2. **Формирование URL**: Если `date` пустая, URL будет: `/routes/search?from=Якутск&to=Мирный`
3. **Нет валидации формата**: Если `date` = `'invalid-date'`, она все равно добавится в URL

### Проблемы:

1. **Пустая строка `date`**: Не добавляется в URL, что корректно
2. **Неверный формат `date`**: Если `date` = `'invalid-date'`, она добавится в URL, и backend может вернуть ошибку
3. **Нет проверки до `fetchApi`**: Нет валидации формата `date` перед вызовом `fetchApi`

### Вывод:

`queryFn` будет вызван, если `enabled = true`. Пустая строка `date` не блокирует выполнение, но неверный формат может вызвать ошибку на backend.

---

## Шаг 6. Валидация данных до запроса

### Проверка наличия валидации:

1. **В `page.tsx`**: Нет валидации параметров из URL
2. **В `useRoutesSearch`**: Нет валидации параметров перед формированием `queryKey` или вызовом `queryFn`
3. **В `search-form.tsx`**: Есть валидация через `RouteSearchParamsWithValidationSchema.parse()`, но она применяется только при отправке формы

### Проблема:

**Критическая проблема:** Если пользователь переходит по прямой ссылке с неверным форматом `date` (например, `/routes?from=Якутск&to=Мирный&date=invalid`):
- Параметры читаются из URL без валидации
- Передаются в `useRoutesSearch` без проверки
- Неверный `date` попадает в `queryKey` и в URL запроса
- Backend может вернуть ошибку, которая маскируется под сетевую

### Вывод:

Нет валидации параметров из URL перед использованием в `useRoutesSearch`. Неверный формат `date` может вызвать проблемы.

---

## Шаг 7. Проверка retry

### Файл: `frontend/src/modules/routes/hooks/use-routes-search.ts`

**Строки 144-160:**
```typescript
retry: (failureCount, error) => {
  const apiError = error as ApiError
  if (apiError?.status === 404) {
    return false
  }
  if (apiError?.status === 503) {
    return false
  }
  if (apiError?.code === 'INVALID_ROUTE_RESPONSE') {
    return false
  }
  return failureCount < 2
},
```

### Анализ:

1. **Ошибки 404**: Не повторяются
2. **Ошибки 503**: Не повторяются
3. **Ошибки валидации**: Не повторяются
4. **Другие ошибки**: Повторяются до 2 раз

### Проблема:

Если backend вернет ошибку из-за неверного формата `date` (например, 400 Bad Request), то:
- Ошибка не будет иметь `status = 404` или `503`
- Ошибка не будет иметь `code = 'INVALID_ROUTE_RESPONSE'`
- Запрос будет повторен до 2 раз
- Но это не блокирует первоначальный запрос

### Вывод:

`retry` не блокирует выполнение `queryFn`. Он только контролирует повторные попытки после ошибки.

---

## Шаг 8. Финальный вывод

### Точная причина, почему запрос не отправляется:

**Основная проблема:** Параметр `date` передается как пустая строка `''` из URL в `useRoutesSearch`, но это не должно блокировать запрос, так как `enabled` проверяет только `from` и `to`.

**Вероятная причина:** Если `date` присутствует в URL как пустая строка (например, `?from=Якутск&to=Мирный&date=`), то:
1. `searchParams.get('date')` вернет пустую строку `''`
2. Пустая строка попадает в `queryKey`: `['routes', 'search', 'Якутск', 'Мирный', '', '1']`
3. React Query может создать отдельный кеш для этого ключа
4. Если пользователь затем меняет `date` на реальную дату, React Query создаст новый кеш
5. Но это не должно блокировать запрос

**Альтернативная причина:** Если `date` передается в неверном формате (например, `'invalid-date'`), то:
1. Неверный формат попадает в `queryKey`
2. В `queryFn` неверный формат добавляется в URL: `/routes/search?from=Якутск&to=Мирный&date=invalid-date`
3. Backend может вернуть ошибку 400
4. Ошибка обрабатывается как сетевая, и UI показывает "Не удалось подключиться к серверу"

### Место блокировки:

**Нет явной блокировки запроса.** Проблема в том, что:
1. **Строка 97**: Пустая или неверная `date` попадает в `queryKey`, что может вызвать проблемы с кешированием
2. **Строка 142**: `enabled` не проверяет формат `date`, поэтому запрос выполняется даже с неверным форматом
3. **Строка 104**: Пустая строка `date` не добавляется в URL, что корректно, но неверный формат добавляется

### Конкретный параметр, вызывающий остановку:

**Параметр `date`** является наиболее вероятной причиной:
- Может быть пустой строкой `''`
- Может быть в неверном формате (не `YYYY-MM-DD`)
- Не валидируется перед использованием
- Попадает в `queryKey` без нормализации

### Точная строка и модуль:

**Файл:** `frontend/src/modules/routes/hooks/use-routes-search.ts`
- **Строка 97**: `queryKey: ['routes', 'search', normalizedFrom, normalizedTo, date, passengers]` - `date` попадает в ключ без валидации
- **Строка 142**: `enabled: Boolean(normalizedFrom && normalizedTo)` - не проверяет формат `date`
- **Строка 104**: `if (date)` - проверяет только наличие, не формат

**Файл:** `frontend/src/app/routes/page.tsx`
- **Строка 29**: `const date = searchParams.get('date') || ''` - может вернуть пустую строку
- **Строка 32**: Параметры передаются в `useRoutesSearch` без валидации

### Почему UI подменяет ошибку:

Если backend возвращает ошибку из-за неверного формата `date` (например, 400 Bad Request), то:
1. Ошибка обрабатывается в `fetchApi` (файл `frontend/src/shared/utils/api.ts`)
2. Если ошибка не имеет специфического кода, она преобразуется в общую сетевую ошибку
3. В `useRoutesSearch` (строка 230) ошибка обрабатывается как `apiError`
4. В `page.tsx` (строка 67) общая ошибка отображается как "Произошла ошибка при поиске маршрутов" или "Не удалось подключиться к серверу"

---

## Рекомендации

1. **Нормализовать `date`** в `useRoutesSearch`: применять `.trim()` и проверять на пустую строку
2. **Валидировать `date`** перед добавлением в `queryKey`: если `date` пустая или неверного формата, не включать ее в ключ
3. **Добавить валидацию в `page.tsx`**: проверять формат параметров из URL перед передачей в `useRoutesSearch`
4. **Улучшить обработку ошибок**: различать ошибки валидации параметров от сетевых ошибок

